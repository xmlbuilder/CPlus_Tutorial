# 🧠 템플릿의 본질: 코드 생성
- C++의 템플릿은 컴파일 타임에 타입에 따라 실제 코드로 인스턴스화됩니다.
- 예를 들어:
```cpp
template<typename T>
T add(T a, T b) {
    return a + b;
}

int x = add<int>(3, 4); // → 컴파일 시점에 add<int> 함수 생성
```

- 이건 마치 int add(int a, int b)라는 함수를 자동으로 생성한 것과 같아요.
- 즉, 템플릿은 **코드 영역 (.text)**에 들어갑니다 — 데이터 영역이 아니라요!

## 📦 템플릿이 생성하는 것들
|생성 대상|메모리 위치|설명|
|---------|----------|-----|
| 함수 템플릿 인스턴스 | 코드 영역(.text)  | 타이별로 함수가 생성됨  | 
| 클래스 템플릿 인스턴스 | 힙/스택/데이터 영역 | 객체 생성 위치에 따라 달라짐 | 
| static 멤버 변수(템플릿 클래스 내부) | 데이터 영역 | 타입별로 따로 생성됨  | 



## 🎯 예외: static 멤버 변수
```cpp
template<typename T>
class Counter {
public:
    static int count;
};

template<typename T>
int Counter<T>::count = 0;
```

- 여기서 Counter<int>::count와 Counter<float>::count는 각각 데이터 영역에 따로 존재해요.
- 이건 템플릿이 타입별로 static 변수를 생성하기 때문이에요.

## 🔍 정리하면
- 템플릿 자체는 코드 생성 도구이고,
생성된 함수나 클래스는 일반적인 C++ 코드처럼 메모리에 배치됩니다.
- 데이터 영역에 들어가는 건 static 변수일 때만 해당돼요.
- 대부분의 템플릿 인스턴스는 **코드 영역이나 객체 생성 위치(스택/힙)**에 들어가요.
---

