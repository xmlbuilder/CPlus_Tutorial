# Windows에서 **긴 경로 + 한글(UTF-8) 경로** 안전 처리 가이드

Windows는 기본적으로 `MAX_PATH`(260자) 제한과 코드페이지(ANSI) 이슈 때문에,  
표준 C/C++ API를 그대로 쓰면 **긴 경로**나 **한글 경로**에서 실패합니다.  
이 문서는 두 가지 실전 해법을 제공합니다.

- 방법 A: **UTF-8 → UTF-16** 변환 + **`_wfopen`** + **확장 경로(`\\?\`)**
- 방법 B: **`std::filesystem::path`를 wide 기반으로 생성**하여 스트림/FS API 사용

둘 다 **상대경로가 아닌 절대경로**에 적용해야 하며, UNC 경로는 `\\?\UNC\server\share\...` 규칙을 지켜야 합니다.

---

## 방법 A) `_wfopen`으로 직접 열기 (가장 단순/안정)

```cpp
#include <windows.h>
#include <string>
#include <cstdio>
#include <algorithm>

// UTF-8 -> UTF-16
static std::wstring utf8_to_wide(const std::string& s) {
    if (s.empty()) return {};
    int len = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), nullptr, 0);
    std::wstring w(len, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), &w[0], len);
    return w;
}

// 절대화 + 슬래시 정규화 + \\?\ / \\?\UNC\ 접두어
static std::wstring win_make_extended_abs(std::wstring path) {
    std::replace(path.begin(), path.end(), L'/', L'\\');

    // 절대경로 만들기
    wchar_t buf[32768];
    DWORD n = GetFullPathNameW(path.c_str(), (DWORD)(std::size(buf)), buf, nullptr);
    if (n > 0 && n < std::size(buf)) path.assign(buf, n);

    // 이미 확장경로면 그대로
    if (path.rfind(LR"(\\?\)", 0) == 0) return path;

    // UNC: \\server\share\... -> \\?\UNC\server\share\...
    if (path.rfind(LR"(\\)", 0) == 0) return std::wstring(LR"(\\?\UNC\)") + path.substr(2);

    // 드라이브 절대경로
    return std::wstring(LR"(\\?\)") + path;
}

bool fopen_u8_long(const std::string& utf8Path, const wchar_t* wmode, FILE*& fp) {
    std::wstring w = utf8_to_wide(utf8Path);
    std::wstring longW = win_make_extended_abs(w);
    fp = _wfopen(longW.c_str(), wmode);
    return (fp != nullptr);
}
```

## 사용 예
```cpp
FILE* fp = nullptr;
std::string path = u8R"(D:\작업\아주아주아주긴\경로\파일.txt)";

if (fopen_u8_long(path, L"wb", fp)) {
    const char* msg = "hello\n";
    fwrite(msg, 1, strlen(msg), fp);
    fclose(fp);
}
```

## 팁
- ASCII 규약이면 BOM 없이 ASCII 바이트만 기록하세요.
- L"wt, ccs=UTF-8" 모드는 디버그 CRT에서 assert가 발생할 수 있으니 주의.

---

## 방법 B) std::filesystem::path(wide)로 열기

```cpp
#include <windows.h>
#include <filesystem>
#include <fstream>
#include <string>
#include <algorithm>

namespace fs = std::filesystem;

static std::wstring utf8_to_wide(const std::string& s) {
    if (s.empty()) return {};
    int len = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), nullptr, 0);
    std::wstring w(len, L'\0');
    MultiByteToWideChar(CP_UTF8, 0, s.c_str(), (int)s.size(), &w[0], len);
    return w;
}

static std::wstring win_make_extended_abs(std::wstring path) {
    std::replace(path.begin(), path.end(), L'/', L'\\');
    wchar_t buf[32768];
    DWORD n = GetFullPathNameW(path.c_str(), (DWORD)(std::size(buf)), buf, nullptr);
    if (n > 0 && n < std::size(buf)) path.assign(buf, n);
    if (path.rfind(LR"(\\?\)", 0) == 0) return path;
    if (path.rfind(LR"(\\)", 0) == 0) return std::wstring(LR"(\\?\UNC\)") + path.substr(2);
    return std::wstring(LR"(\\?\)") + path;
}

fs::path make_fs_longpath_from_utf8(const std::string& utf8) {
    return fs::path(win_make_extended_abs(utf8_to_wide(utf8)));
}

// 예시
std::string p = u8R"(D:\작업\아주긴\경로\파일.txt)";
fs::path pathW = make_fs_longpath_from_utf8(p);

std::ofstream ofs(pathW, std::ios::binary);
if (ofs) {
    ofs << "hello\n";
}
```

---

## 체크리스트 (Windows)

-절대경로에 \\?\ 적용
-UNC 경로는 \\?\UNC\server\share\...
-상대경로에는 \\?\ 사용 불가
-각 경로 세그먼트는 255자 이하
-경로 끝 공백/점 제거
-ASCII 규약이면 BOM 없이 ASCII만 기록

## Linux/macOS에서는?
- 대부분 UTF-8 경로 지원
- std::filesystem::u8path() 정상 동작
- MAX_PATH 제약 없음 (보통 전체 경로 4096바이트 제한)
- UTF-8 로케일 필요 (LANG=ko_KR.UTF-8)
- 기존 소스가 UTF-8이면 문제 거의 없음

## 결론
Windows: UTF-8→UTF-16 + 확장 경로(\\?\) + _wfopen 또는 wide 기반 std::filesystem::path
Linux: UTF-8 로케일만 맞추면 기존 소스로 충분