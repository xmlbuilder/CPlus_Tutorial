# 매크로 및 정적 타입을 통한 클래스 자동 등록

## 🧠 핵심 개념 요약
| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 정적 초기화 트릭    | 전역 객체의 생성 시점에 등록 코드 실행 (main 이전에 자동 실행됨)         |
| 매크로 자동화       | 클래스 이름과 등록 함수를 매크로로 묶어 반복 없이 간편하게 등록 가능       |
| 팩토리 패턴 활용    | 문자열 키 → 생성자 함수 매핑으로 동적 객체 생성 가능                       |
| 확장성              | 새로운 타입 추가 시 매크로 한 줄로 등록 가능                             |



## 🛠️ 예시 코드: 자동 등록 매크로
```cpp
// Factory.h
#include <unordered_map>
#include <string>
#include <functional>
#include <memory>

class Base {
public:
    virtual void Speak() = 0;
    virtual ~Base() = default;
};

class Factory {
public:
    using Creator = std::function<std::unique_ptr<Base>()>;

    static void Register(const std::string& name, Creator creator) {
        GetRegistry()[name] = creator;
    }

    static std::unique_ptr<Base> Create(const std::string& name) {
        auto it = GetRegistry().find(name);
        if (it != GetRegistry().end()) return it->second();
        return nullptr;
    }

private:
    static std::unordered_map<std::string, Creator>& GetRegistry() {
        static std::unordered_map<std::string, Creator> registry;
        return registry;
    }
};
```


## 🧩 등록 매크로 + 정적 객체
```cpp
// AutoRegister.h
#define REGISTER_TYPE(TYPE) \
    namespace { \
        struct TYPE##AutoRegister { \
            TYPE##AutoRegister() { \
                Factory::Register(#TYPE, []() { return std::make_unique<TYPE>(); }); \
            } \
        }; \
        static TYPE##AutoRegister global_##TYPE##AutoRegister; \
    }
```


## 🐶 예시 클래스
```cpp
class Dog : public Base {
public:
    void Speak() override { std::cout << "Woof!" << std::endl; }
};
REGISTER_TYPE(Dog)

class Cat : public Base {
public:
    void Speak() override { std::cout << "Meow!" << std::endl; }
};
REGISTER_TYPE(Cat)
```


## ✅ 사용
```cpp
int main() {
    auto pet1 = Factory::Create("Dog");
    auto pet2 = Factory::Create("Cat");

    if (pet1) pet1->Speak();  // Woof!
    if (pet2) pet2->Speak();  // Meow!
}
``` 


## 💡 팁
- 이 방식은 main 이전에 자동 등록되므로, 별도 초기화 코드 없이도 동작
- REGISTER_TYPE 매크로는 클래스 정의 바로 아래에 붙이면 깔끔하게 정리됨
- 필요 시 typeid(T).name() 기반으로도 키를 자동 생성 가능 (단, 플랫폼 종속성 주의)



## 🔍 MFC 매크로 자동 등록의 숨은 의미
MFC는 내부적으로 **런타임 클래스 정보(RTTI)**와 메시지 라우팅 시스템을 구현하기 위해 매크로를 적극 활용해요. 
특히 CRuntimeClass 기반의 동적 생성 시스템은 C++의 리플렉션 부재를 보완하려는 시도였죠.
### 대표적인 매크로들 요약
| 매크로                  | 역할 설명                                                                 |
|--------------------------|---------------------------------------------------------------------------|
| IMPLEMENT_DYNCREATE      | 클래스 이름과 생성자 정보를 MFC 런타임에 등록 (동적 생성 가능하게 함)       |
| DECLARE_DYNCREATE        | 헤더에 클래스 등록 선언                                                    |
| BEGIN_MESSAGE_MAP        | 메시지 핸들러 등록 시작 (윈도우 메시지 → 멤버 함수 연결)                   |
| AFX_MANAGE_STATE         | DLL에서 MFC 상태 관리 (리소스/메모리 누수 방지용)                          |



## 🧠 C++에서의 매크로 자동 등록과 연결되는 개념
MFC의 IMPLEMENT_DYNCREATE는 사실상 우리가 앞서 얘기한 정적 초기화 + 생성자 등록 패턴의 MFC 버전이에요. 내부적으로 CRuntimeClass 배열에 클래스 정보를 넣고, 문자열로 객체를 생성할 수 있게 해주는 구조죠.
예시 흐름
// 내부적으로 이런 식으로 동작
```cpp
CRuntimeClass* pClass = RUNTIME_CLASS(CMyDialog);
CObject* pObj = pClass->CreateObject();  // 동적 생성
```

이게 바로 우리가 C++에서 Factory::Register("Dog", ...) 했던 것과 똑같은 구조예요. 
단지 MFC는 이걸 매크로로 감싸서 자동화한 거죠.

## 🤹‍♂️ 그때는 몰랐지만 지금은 보이는 것들
- “왜 붙이는지 몰랐던 매크로” → 사실은 동적 생성과 메시지 라우팅을 위한 핵심 인프라
- “붙이면 돌아가니까 붙였다” → 알고 보면 C++에서 리플렉션을 흉내 내기 위한 고급 트릭
- “지금은 내가 직접 구현하고 있다” → MFC가 했던 걸 더 유연하게, 더 현대적으로 구현 중!


## Qt
**Meta-Object Compiler (moc)**라는 독특한 방식을 사용하죠. 
우리가 QObject를 상속하고 Q_OBJECT 매크로를 붙이면, Qt는 자동으로 moc_클래스이름.cpp 파일을 생성해서 런타임 메타 정보, 시그널/슬롯 연결, 동적 객체 생성 등을 가능하게 해줌.

## 🧠 Qt의 moc 시스템 핵심 요약
| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| Q_OBJECT 매크로   | 클래스에 메타정보 생성 지시 (시그널/슬롯, RTTI 등)                     |
| moc 파일 생성     | 빌드 시 `moc_클래스이름.cpp` 자동 생성 (메타정보 포함)                  |
| 시그널/슬롯 연결  | 문자열 기반으로 런타임에 연결 가능 (`connect(sender, SIGNAL(...), ...)`) |
| 동적 생성 지원    | `QMetaObject::newInstance()`로 객체 생성 가능 (생성자 등록 필요)         |
| 리플렉션 대체     | C++의 리플렉션 부재를 moc로 보완 (속성, 메서드, 클래스 정보 접근 가능)     |



## 🔧 예시 흐름
```cpp
class MyWidget : public QWidget {
    Q_OBJECT

public:
    MyWidget(QWidget* parent = nullptr);

signals:
    void somethingHappened();

public slots:
    void handleSomething();
};
```

이렇게 하면 Qt는 moc_MyWidget.cpp를 생성해서 QMetaObject, qt_static_metacall, metaObject() 등을 구현해줘요. 
덕분에 런타임에 클래스 이름으로 객체를 생성하거나, 시그널/슬롯을 문자열로 연결할 수 있죠.

## 🤖 C++에서 직접 구현하려면?
Qt처럼 하려면 다음이 필요함:
- 클래스 이름 → 생성자 매핑 (Factory)
- 시그널/슬롯 → 함수 포인터 또는 std::function 기반 이벤트 시스템
- 메타정보 → 수동 등록 (속성 이름, 타입 등)
즉, Qt는 moc를 통해 우리가 앞서 만든 REGISTER_TYPE, TypeRegistry, Factory 패턴을 자동화한 고급 버전이라고 볼 수 있어요.
