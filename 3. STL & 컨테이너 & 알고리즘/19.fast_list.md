# 🚀 TFastList: 고속 커스텀 리스트 컨테이너
## 📌 개요
TFastList는 chunk 기반 메모리 매니저(CFixedAllocNoSync)를 활용하여 빠른 메모리 할당과 해제를 지원하는 커스텀 리스트 컨테이너입니다.  일반적인 std::list보다 성능이 우수하며, 반복자(iterator)를 직접 구현하여 STL 스타일의 순회가 가능합니다.

## 🧠 설계 특징
| 항목 | 설명 |
|------|-----| 
| 메모리 관리 | CFixedAllocNoSync를 통해 ITEM 단위 chunk 메모리 할당 | 
| 데이터 구조 | 이중 연결 리스트 (prev/next 포인터 포함) | 
| 반복자 | STL 스타일의 ++, --, *, ==, != 연산자 지원 | 
| 삽입 | push_back, push_front 지원 | 
| 삭제 | erase(iterator)로 노드 제거 | 
| 초기화 | clear()로 전체 메모리 해제 및 리스트 초기화 | 



## 🧱 핵심 구조
### 🔹 ITEM 구조체
```cpp
struct ITEM {
    Type data;
    ITEM* prev;
    ITEM* next;
    ITEM() : prev(0), next(0) {}
};
```

### 🔹 반복자(iterator)
```cpp
class iterator {
    ITEM* m_pItem;
    // ++, --, *, ==, != 연산자 오버라이딩
};
```

## 🔹 주요 메서드
```cpp
void push_back(const Type& data);
void push_front(const Type& data);
iterator erase(iterator pos);
void clear();
iterator begin();
iterator end();
```


## ⚡ 성능 이점
- new/delete 대신 chunk 단위 메모리 풀을 사용 → 할당 속도 향상
- 메모리 단편화 감소
- 반복자 기반 순회로 STL 호환성 확보
- erase() 시 메모리 즉시 반환 가능

## 🧪 사용 예시
```cpp
TFastList<TEdge> listEdge;
for (auto itr = listEdge.begin(); itr != listEdge.end(); ++itr) {
    arFeatureLine[i++] = (*itr);
}
```

## 전체 소스
```cpp
#pragma once
#include "fixalloc.h"
template <class Type>
class TFastList
{
public:
    struct ITEM {       
        Type        data;
        ITEM*       prev;
        ITEM*       next;
        ITEM() : prev(0), next(0) {}
    };
    TFastList(): m_pHead(0), m_pTail(0), m_nSize(0) 
    {
        m_pAx = new CFixedAllocNoSync(sizeof(ITEM));
    }
    ~TFastList() 
    { 
        clear(); 
        if( m_pAx )
        {
            delete m_pAx;
        }
    }
    class iterator
    {
    public:
        friend class TFastList;
        iterator() : m_pItem(0) {}
        iterator(ITEM* pItem) : m_pItem(pItem) {}
        //오퍼레이터 재정의
        //iterator 하나 증가
        iterator& operator++()
        {
            m_pItem = m_pItem->next;
            return *this;
        }
        iterator operator++(int)
        {
            iterator Temp = *this;
            m_pItem = m_pItem->next;
            return Temp;
        }
        //iterator 하나 감소
        iterator& operator--()
        {
            m_pItem = m_pItem->prev;
            return *this;
        }
        iterator operator--(int)
        {
            iterator Temp = *this;
            m_pItem = m_pItem->prev;
            return Temp;
        }
        //해당 iterator의 데이터 가져오기
        Type& operator*()
        {
            return m_pItem->data;
        }
        //iterator 같은지 비교 연산자 재정의
        bool operator==(const iterator& itr)
        {
            if (itr.m_pItem == m_pItem) return true;
            return false;
        }
        //iterator 다른지 비교 연산자 재정의
        bool operator!=(const iterator& itr)
        {
            if (itr.m_pItem != m_pItem) return true;
            return false;
        }
    protected:
        ITEM* m_pItem;
    };
public:
    friend class iterator;
    //iterator 관련 기본 함수들
    iterator begin() { return iterator(m_pHead); }
    iterator end() { return iterator(0); }
    unsigned int size() { return m_nSize; }
    bool empty() { return (m_nSize==0); }
    
    void push_back(const Type& data)
    {
        m_nSize++;
        ITEM* pItem = (ITEM*)m_pAx->Alloc();
        ASSERT( pItem );
        pItem->data = data;
        pItem->prev = m_pTail;
        pItem->next = 0;
        if (m_pTail) 
        { 
            m_pTail->next = pItem; 
            m_pTail = pItem; 
        }
        else m_pHead = m_pTail = pItem;
    }

    void push_front(const Type& data)
    {
        m_nSize++;
        ITEM* pItem = (ITEM*)m_pAx->Alloc();
        ASSERT( pItem );
        pItem->data = data;
        pItem->prev = 0;
        pItem->next = m_pHead;
        if (m_pHead) 
        { 
            m_pHead->prev = pItem; 
            m_pHead = pItem; 
        }
        else m_pHead = m_pTail = pItem;
    }

    void clear()
    {
        m_pAx->FreeAll();
        m_pHead = 0;
        m_pTail = 0;
        m_nSize = 0;
    }

    iterator erase(iterator pos)
    {
        m_nSize--;
        ITEM* pPrev = pos.m_pItem->prev;
        ITEM* pNext = pos.m_pItem->next;
        if (pPrev == 0) m_pHead = pNext;
        else pPrev->next = pNext;
        if (pNext == 0) m_pTail = pPrev;
        else pNext->prev = pPrev;
        m_pAx->Free(pos.m_pItem);       
        return iterator(pNext);
    }
protected:
    ITEM* m_pHead;
    ITEM* m_pTail;
    CFixedAllocNoSync* m_pAx;
    unsigned int m_nSize;
};

TFastList<TEdge>    listEdge;
TFastList<TEdge>::iterator itr;
for (itr = listEdge.begin(); itr != listEdge.end(); ++itr)
{
    arFeatureLine[i++] = (*itr);
}

```



## 📌 확장 아이디어
- reverse_iterator 추가
- insert(iterator, Type) 지원
- find, sort, merge 등 STL 유사 기능 확장
