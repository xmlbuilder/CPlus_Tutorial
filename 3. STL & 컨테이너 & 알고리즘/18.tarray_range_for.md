# 🔄 Range-based for in Custom Array (TArray)

C++11부터는 `range-based for` 문법을 통해 컨테이너 순회가
간결해졌습니다.\
기본 STL 컨테이너는 이를 지원하지만, 커스텀 컨테이너는 직접
**iterator**와 `begin`, `end`를 구현해야 합니다.

------------------------------------------------------------------------

## 🛠 Iterator 클래스 구현

먼저 포인터 기반으로 동작하는 간단한 `Iterator`를 정의합니다.

``` cpp
template<class Type>
class Iterator
{
public:
    Iterator() : _data(nullptr) {}
    explicit Iterator(Type* data) : _data(data) {}

    bool operator==(const Iterator& other) { return _data == other._data; }
    bool operator!=(const Iterator& other) { return _data != other._data; }

    void operator++() { ++_data; }
    Type& operator*() { return *_data; }

public:
    Type* _data;
};
```

-   내부적으로 **포인터**를 저장하고 이동/역참조 기능을 제공합니다.\
-   `operator==`, `operator!=`, `operator++`, `operator*` 를 정의해야
    range-based for 사용이 가능합니다.

------------------------------------------------------------------------

## 📦 TArray 클래스 확장

기존 배열 클래스 `TArray`에 `begin()` / `end()`를 추가합니다.

``` cpp
template<class Type>
class TArray {
public:
    using iterator = Iterator<Type>;

    explicit TArray(int lSize) : m_pData(nullptr) { setSize(lSize); }
    TArray() : m_pData(nullptr), m_lSize(0) {}
    ~TArray() { removeAll(); }

    // 크기 설정
    void setSize(const int lSize) {
        if (lSize <= 0) {
            removeAll();
            return;
        }
        delete[] m_pData;
        m_pData = new Type[lSize];
        m_lSize = lSize;
    }

    // 크기 반환
    int getSize() const { return m_lSize; }

    // 인덱스 접근
    Type& operator[](int nIndex) {
        assert(nIndex >= 0 && nIndex < m_lSize);
        return m_pData[nIndex];
    }

    // 반복자 지원
    iterator begin() { return iterator(&m_pData[0]); }
    iterator end() { return iterator(&m_pData[m_lSize]); }

private:
    Type* m_pData;
    int m_lSize{};
};
```

------------------------------------------------------------------------

## 🔍 사용 예제

``` cpp
#include <iostream>

int main() {
    TArray<float> taData;
    taData.setSize(5);

    for (auto& data : taData) {
        data = 100;
    }

    for (auto& data : taData) {
        std::cout << data << std::endl;
    }

    /*
    출력:
    100
    100
    100
    100
    100
    */
}
```

------------------------------------------------------------------------

## 📌 정리

-   `Iterator` 클래스는 포인터처럼 동작하도록 구현\
-   `TArray`에서 `begin()` / `end()` 정의 → **range-based for 지원**\
-   커스텀 컨테이너도 STL처럼 간결하게 사용할 수 있음

👉 이 패턴을 응용하면 다양한 커스텀 자료구조에 `range-based for`를 쉽게
적용할 수 있습니다.
