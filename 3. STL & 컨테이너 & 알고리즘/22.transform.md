# 🛠️ std::transform 개요
std::transform은 입력 범위의 각 요소에 대해 지정된 연산을 수행하고, 그 결과를 출력 범위에 저장하는 알고리즘입니다.  
std::transform(input_begin, input_end, output_begin, unary_op);  
std::transform(input1_begin, input1_end, input2_begin, output_begin, binary_op);

- Unary transform: 하나의 입력 범위에 대해 단일 함수 적용
- Binary transform: 두 입력 범위의 요소를 쌍으로 받아 함수 적용

## ✨ 예제 1: 문자열 대문자 변환 및 ASCII 코드 출력
```cpp
#include <algorithm>
#include <cctype>
#include <iostream>
#include <string>
#include <vector>

int main() {
    std::string s("hello");

    // 문자열을 대문자로 변환
    std::transform(s.begin(), s.end(), s.begin(),
        [](unsigned char c) { return std::toupper(c); });

    // 각 문자에 대한 ASCII 코드 저장
    std::vector<std::size_t> ordinals;
    std::transform(s.begin(), s.end(), std::back_inserter(ordinals),
        [](unsigned char c) { return static_cast<std::size_t>(c); });

    std::cout << s << ":";
    for (auto ord : ordinals) {
        std::cout << ' ' << ord;
    }
    std::cout << '\n';
}
// 출력: HELLO: 72 69 76 76 79
```


## ✨ 예제 2: 벡터 요소 변환 및 추가
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> myvector {1, 2, 3, 4, 5};
    std::vector<int> output(4, 10); // 초기값 10 네 개

    // myvector의 각 요소에 2를 곱하여 output 뒤에 추가
    std::transform(myvector.begin(), myvector.end(), std::back_inserter(output),
        [](int n) { return n * 2; });

    for (const auto& val : output) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}
// 출력: 10 10 10 10 2 4 6 8 10
```


## ✨ 예제 3: map, filter, reduce 스타일
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> nums{1, 2, 3, 4};

    // map: 제곱
    std::vector<int> map_example;
    std::transform(nums.begin(), nums.end(), std::back_inserter(map_example),
        [](int x) { return x * x; });

    // filter: 짝수만
    std::vector<int> filter_example;
    std::copy_if(nums.begin(), nums.end(), std::back_inserter(filter_example),
        [](int x) { return x % 2 == 0; });

    // reduce: 곱셈 누적
    int reduce_example = std::accumulate(nums.begin(), nums.end(), 1,
        [](int x, int y) { return x * y; });

    for (int i : map_example) std::cout << i << "\t"; // 1 4 9 16
    std::cout << "\n";
    for (int i : filter_example) std::cout << i << "\t"; // 2 4
    std::cout << "\n";
    std::cout << reduce_example << "\n"; // 24
}
```

## ✨ 예제 4: std::accumulate와 문자열 접기
```cpp
#include <iostream>
#include <numeric>
#include <string>
#include <vector>
#include <functional>

int main() {
    std::vector<int> v{1,2,3,4,5,6,7,8,9,10};

    int sum = std::accumulate(v.begin(), v.end(), 0);
    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());

    auto dash_fold = [](std::string a, int b) {
        return std::move(a) + '-' + std::to_string(b);
    };

    std::string s = std::accumulate(std::next(v.begin()), v.end(), std::to_string(v[0]), dash_fold);
    std::string rs = std::accumulate(std::next(v.rbegin()), v.rend(), std::to_string(v.back()), dash_fold);

    std::cout << "sum: " << sum << "\n";
    std::cout << "product: " << product << "\n";
    std::cout << "dash-separated string: " << s << "\n";
    std::cout << "dash-separated string (right-folded): " << rs << "\n";
}
```



## ✨ 예제 5: transform vs for 루프 비교
```cpp
std::vector<int> src = {1, 2, 3, 4, 5};
std::vector<int> dst;

// 전통적인 for 루프
for (int i = 0; i < src.size(); ++i) {
    dst.emplace_back(src[i] * 2);
}

// transform 방식
dst.resize(src.size());
std::transform(src.begin(), src.end(), dst.begin(),
    [](int x) { return x * x; });
```

## 🔁 Binary std::transform 예제
두 개의 입력 범위를 받아서 각 요소 쌍에 대해 연산을 수행하는 방식입니다.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> a{1, 2, 3, 4, 5};
    std::vector<int> b{10, 20, 30, 40, 50};
    std::vector<int> result;

    // 두 벡터의 각 요소를 더해서 result에 저장
    std::transform(a.begin(), a.end(), b.begin(), std::back_inserter(result),
        [](int x, int y) { return x + y; });

    for (int val : result) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}
// 출력: 11 22 33 44 55
```

📌 주의사항:
- 두 입력 범위의 길이는 같아야 합니다. 그렇지 않으면 정의되지 않은 동작이 발생할 수 있어요.
- std::back_inserter를 사용하면 result의 크기를 미리 지정하지 않아도 됩니다.

## 🌊 std::ranges::transform (C++20 이후)
```cpp
범위 기반으로 더 안전하고 간결하게 transform을 사용할 수 있게 해주는 기능입니다.
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> nums{1, 2, 3, 4, 5};
    std::vector<int> squares(nums.size());

    // 범위 기반 transform
    std::ranges::transform(nums, squares.begin(),
        [](int x) { return x * x; });

    for (int val : squares) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}
// 출력: 1 4 9 16 25
```

### ✅ 장점
- begin()/end()를 직접 지정할 필요 없이 컨테이너 자체를 범위로 사용 가능
- 컨셉 기반 제약으로 컴파일 타임에 타입 오류를 잡아줌
- views와 함께 사용하면 **지연 평가(lazy evaluation)**도 가능

## 🧪 std::ranges::transform + views 예제
```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> nums{1, 2, 3, 4, 5};

    // 제곱값을 지연 평가로 생성
    auto squared_view = nums | std::views::transform([](int x) { return x * x; });

    for (int val : squared_view) {
        std::cout << val << " ";
    }
    std::cout << "\n";
}
// 출력: 1 4 9 16 25
```

💡 views::transform은 결과를 즉시 저장하지 않고, 필요할 때 계산합니다.  
메모리 효율이 뛰어나고, 파이프라인 스타일로 작성할 수 있어 가독성도 좋습니다.

## 🌊 std::ranges::transform + filter-map-reduce
C++20의 <ranges> 라이브러리를 활용하면 filter, transform, accumulate를 조합해 파이프라인 스타일로 데이터를 처리할 수 있습니다.

### 🔧 예제 코드
```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <numeric> // for std::accumulate

int main() {
    std::vector<int> nums{1, 2, 3, 4, 5, 6};

    // 1. filter: 짝수만 선택
    auto filtered = nums | std::views::filter([](int x) { return x % 2 == 0; });

    // 2. map(transform): 제곱
    auto mapped = filtered | std::views::transform([](int x) { return x * x; });

    // 3. reduce(accumulate): 합산
    int reduced = std::accumulate(mapped.begin(), mapped.end(), 0);

    // 출력
    std::cout << "Filtered & Squared: ";
    for (int val : mapped) {
        std::cout << val << " ";
    }
    std::cout << "\nSum: " << reduced << "\n";
}
```

### ✅ 실행 결과
```
Filtered & Squared: 4 16 36
Sum: 56
```


## 🧠 핵심 개념 요약
| 단계 | 기능 설명 | C++ 표현 방식 |
|-----|----------|--------------| 
| Filter | 조건에 맞는 요소만 선택 | std::views::filter(predicate) | 
| Map | 각 요소에 연산 적용 | std::views::transform(function) | 
| Reduce | 모든 요소를 하나의 값으로 축약 | std::accumulate(begin, end, init) | 



## 💡 팁
- views는 **지연 평가(lazy evaluation)**를 지원하므로 성능이 뛰어납니다.
- auto를 적극 활용하면 코드가 간결해지고 가독성이 좋아집니다.
- std::ranges::transform은 views::transform과 달리 결과를 즉시 저장할 때 사용합니다.

---


# 🧠 std::accumulate 개념 요약
T std::accumulate(InputIt first, InputIt last, T init);
T std::accumulate(InputIt first, InputIt last, T init, BinaryOp op);


- init: 누적의 시작값
- op: 두 값을 받아 누적하는 함수 (기본은 +)
- C++11부터는 람다를 자유롭게 사용 가능

## 🔍 C++11 스타일 보강 포인트
### ✅ 1. 람다를 활용한 커스텀 누적
auto sum = std::accumulate(v.begin(), v.end(), 0,
    [](int acc, int val) { return acc + val; });


- std::plus<int>() 대신 람다를 쓰면 더 유연하게 조건 추가 가능

### ✅ 2. 조건 누적 (예: 짝수만 더하기)
int even_sum = std::accumulate(v.begin(), v.end(), 0,
    [](int acc, int val) {
        return val % 2 == 0 ? acc + val : acc;
    });

- 조건부 누적은 std::copy_if보다 간결하게 처리 가능

### ✅ 3. 구조체 누적 (복합 타입)
```cpp
struct Stats {
    int sum = 0;
    int count = 0;
};

Stats result = std::accumulate(v.begin(), v.end(), Stats{},
    [](Stats acc, int val) {
        acc.sum += val;
        acc.count++;
        return acc;
    });

std::cout << "Average: " << static_cast<double>(result.sum) / result.count << "\n";
```

- C++11의 구조체 초기화와 람다를 조합하면 통계 계산도 깔끔하게 가능

### ✅ 4. 문자열 누적 (fold 스타일)
이미 잘 작성하신 dash_fold 예제에 추가 설명을 붙이자면:
```cpp
auto dash_fold = [](std::string a, int b) {
    return std::move(a) + '-' + std::to_string(b);
};
```

- std::move(a)를 사용하면 복사 비용을 줄일 수 있음
- std::next(v.begin())를 사용해 첫 요소는 초기값으로, 나머지를 누적

### ✅ 5. 오른쪽 fold (reverse iterator)
```cpp
std::string rs = std::accumulate(std::next(v.rbegin()), v.rend(),
                                 std::to_string(v.back()), dash_fold);
```

- std::accumulate는 왼쪽 fold만 지원하지만, reverse iterator를 쓰면 오른쪽 fold처럼 동작

### 🧪 std::function을 이용한 동적 누적 함수
std::function<int(int, int)> custom_op = [](int x, int y) {
    return x * y + 1;
};

int result = std::accumulate(v.begin(), v.end(), 1, custom_op);


- std::function을 쓰면 동적으로 누적 함수를 바꿀 수 있음
- 단, 성능은 람다보다 약간 떨어질 수 있음

## 🧩 전체 요약

| 패턴 | 설명 | 예시 함수 |
|------|------|---------|
| 기본 합산 | 모든 요소 더하기 | + 또는 std::plus<int>() | 
| 조건 누적 | 특정 조건 만족하는 요소만 누적 | if 포함 람다 | 
| 구조체 누적 | 복합 통계 계산 | Stats 구조체 | 
| 문자열 접기 | 요소를 문자열로 연결 | dash_fold | 
| 오른쪽 fold | 마지막부터 접기 | rbegin() 사용 | 
| 동적 연산 | 런타임에 연산 정의 가능 | std::function | 

---

# 🔍 std::copy_if
std::copy_if(input_begin, input_end, output_iterator, predicate);


- 입력 범위에서 조건을 만족하는 요소만 출력 반복자를 통해 복사합니다.
- predicate는 bool을 반환하는 조건 함수입니다.

## 🧪 예제 분석
```cpp
std::copy_if(nums.begin(), nums.end(), std::back_inserter(filter_example),
             [](const auto& x) { return x % 2 == 0; });
```

## 🔧 동작 설명
- nums의 각 요소를 순회
- x % 2 == 0 조건을 만족하는 요소만 선택 (짝수 필터링)
- filter_example 벡터 뒤에 push_back()으로 추가 (std::back_inserter)
📌 const auto& x를 사용하면 타입 추론이 자동으로 되고, 복사 비용도 줄일 수 있어요.

✅ 왜 std::copy_if가 유용한가?
| 장점 | 설명 | 
|-----|------|
| 조건 필터링 | if문 없이 선언적 스타일로 필터링 가능 | 
| 범용성 | 모든 반복자와 컨테이너에 적용 가능 | 
| 람다 지원 | C++11 이후 조건을 자유롭게 정의 가능 | 
| back_inserter와 궁합 | 출력 컨테이너 크기 미리 지정할 필요 없음 | 



## 🧠 다양한 활용 예시
### 1. 홀수만 복사
```cpp
std::copy_if(nums.begin(), nums.end(), std::back_inserter(odds),
             [](int x) { return x % 2 != 0; });
```

### 2. 특정 범위 필터링
```cpp
std::copy_if(nums.begin(), nums.end(), std::back_inserter(in_range),
             [](int x) { return x >= 3 && x <= 7; });
```

### 3. 문자열 길이 필터링
```cpp
std::vector<std::string> words{"cat", "elephant", "dog", "tiger"};
std::vector<std::string> long_words;

std::copy_if(words.begin(), words.end(), std::back_inserter(long_words),
             [](const std::string& s) { return s.length() > 4; });

```

⚠️ 주의사항
- 출력 컨테이너가 push_back()을 지원해야 std::back_inserter 사용 가능 (vector, list, deque)
- std::copy_if는 C11부터 도입된 함수입니다. C03에서는 직접 for 루프를 써야 했어요.


----
