
# ğŸ“Œ C++ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°: `unique_ptr` ì™„ì „ ì •ë³µ

C++ì—ì„œ ë™ì  ë©”ëª¨ë¦¬ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ ë„êµ¬ ì¤‘ í•˜ë‚˜ê°€ ë°”ë¡œ `unique_ptr`ì…ë‹ˆë‹¤.  
ì´ ë¬¸ì„œì—ì„œëŠ” `unique_ptr`ì˜ ì² í•™, ì‚¬ìš©ë²•, ì£¼ì˜ì , ì‹¤ì „ ì˜ˆì œê¹Œì§€ ëª¨ë‘ ë‹¤ë£¹ë‹ˆë‹¤.

---

## ğŸ§  ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ë€?

ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ëŠ” ì¼ë°˜ í¬ì¸í„°ì²˜ëŸ¼ ë™ì‘í•˜ì§€ë§Œ, **ìì› í•´ì œë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬**í•´ì£¼ëŠ” í¬ì¸í„° ê°ì²´ì…ë‹ˆë‹¤.  
C++ì—ì„œëŠ” ìì› ê´€ë¦¬ ì² í•™ìœ¼ë¡œ **RAII (Resource Acquisition Is Initialization)**ë¥¼ ë”°ë¦…ë‹ˆë‹¤.

> RAIIë€ ê°ì²´ê°€ ìƒì„±ë  ë•Œ ìì›ì„ íšë“í•˜ê³ , ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ìì›ì„ í•´ì œí•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.  
> ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ìŠ¤íƒì— ìˆëŠ” ê°ì²´ë“¤ì€ ìë™ìœ¼ë¡œ ì†Œë©¸ë©ë‹ˆë‹¤ (stack unwinding).

---

## ğŸ” `unique_ptr`ì˜ í•µì‹¬ ê°œë…

- íŠ¹ì • ê°ì²´ì˜ **ìœ ì¼í•œ ì†Œìœ ê¶Œ**ì„ ê°–ëŠ” ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°
- `unique_ptr`ì´ ì†Œë©¸ë˜ë©´, **ê°€ë¦¬í‚¤ë˜ ê°ì²´ë„ ìë™ìœ¼ë¡œ delete**
- ë³µì‚¬ ìƒì„±ì/ë³µì‚¬ ëŒ€ì… ì—°ì‚°ìê°€ **ì‚­ì œë˜ì–´ ìˆìŒ**
- ì†Œìœ ê¶Œì„ **ì´ë™í•˜ë ¤ë©´ `std::move()` ì‚¬ìš©**

```cpp
std::unique_ptr<int> p(new int(99));
std::cout << *p << std::endl; // 99
```


## âš ï¸ ì¼ë°˜ í¬ì¸í„°ì˜ ìœ„í—˜ì„±
```cpp
Data* data = new Data();
Data* data2 = data;
delete data;
delete data2; // âŒ ì´ë¯¸ í•´ì œëœ ë©”ëª¨ë¦¬ë¥¼ ë‹¤ì‹œ delete â†’ double free ì˜¤ë¥˜ ë°œìƒ
```

unique_ptrì€ ì´ëŸ° ë¬¸ì œë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ì†Œìœ ê¶Œì„ ëª…í™•íˆ ì •ì˜í•©ë‹ˆë‹¤.


ğŸ› ï¸ ì£¼ìš” ë©¤ë²„ í•¨ìˆ˜
| í•¨ìˆ˜ | ì„¤ëª… | ì£¼ì˜ì  |
|-----|-----|-------| 
| get() | ë‚´ë¶€ í¬ì¸í„° ë°˜í™˜ | ì†Œìœ ê¶Œ ìœ ì§€ | 
| release() | ì†Œìœ ê¶Œ í¬ê¸°, í¬ì¸í„° ë°˜í™˜ | ë°˜í™˜ëœ í¬ì¸í„°ëŠ” ìˆ˜ë™ delete í•„ìš” | 
| reset() | ê¸°ì¡´ ê°ì²´ ì‚­ì œ, ìƒˆ ê°ì²´ ì„¤ì • | ìë™ delete ìˆ˜í–‰ | 
| std::move() | ì†Œìœ ê¶Œ ì´ì „ | ì›ë³¸ì€ nullptrë¡œ ì„¤ì •ë¨ | 



## ğŸ“¦ í•¨ìˆ˜ ì¸ìë¡œ ì „ë‹¬í•˜ê¸°

```cpp
void sub_do_something(UniquePtrTest* ptr) {
    ptr->some();
}

std::unique_ptr<UniquePtrTest> pa(new UniquePtrTest());
sub_do_something(pa.get()); // get()ìœ¼ë¡œ ë‚´ë¶€ í¬ì¸í„° ì „ë‹¬
```


ê°ì²´ì— ì ‘ê·¼ì€ ê°€ëŠ¥í•˜ì§€ë§Œ, ì†Œìœ ê¶Œì€ ìœ ì§€ë©ë‹ˆë‹¤

ğŸš€ std::make_unique (C++14 ì´ìƒ)
auto ptr = std::make_unique<Foo>(3, 5);
ptr->print();

new ì—†ì´ ì•ˆì „í•˜ê²Œ unique_ptr ìƒì„± ê°€ëŠ¥


## ğŸ“š ì»¨í…Œì´ë„ˆì™€ í•¨ê»˜ ì‚¬ìš©í•˜ê¸°

```cpp
std::vector<std::unique_ptr<A>> vec;
vec.emplace_back(new A(1));
vec.back()->some();
```

push_backì€ ë³µì‚¬ ìƒì„±ìê°€ ì—†ì–´ì„œ ì‚¬ìš© ë¶ˆê°€ â†’ emplace_back ì‚¬ìš©


## ğŸ§¹ reset()ê³¼ release() ì˜ˆì œ
std::unique_ptr<TestStuff> ptr(new TestStuff{3, "Hello"});
ptr.reset(); // ë©”ëª¨ë¦¬ í•´ì œ í›„ nullptrë¡œ ì„¤ì •

TestStuff* raw = ptr.release(); // ì†Œìœ ê¶Œ í¬ê¸°
delete raw; // ë°˜ë“œì‹œ ìˆ˜ë™ delete í•„ìš”



## ğŸ”„ ì†Œìœ ê¶Œ ì´ë™: std::move
```cpp
auto ptr1 = std::make_unique<TestStuff>(3, "Hello");
auto ptr2 = std::move(ptr1); // ptr1ì€ nullptr
```

unique_ptrì€ ë³µì‚¬ ë¶ˆê°€, ë°˜ë“œì‹œ std::move()ë¡œ ì†Œìœ ê¶Œ ì´ì „


## ğŸ§® ë°°ì—´ ì²˜ë¦¬
std::unique_ptr<int[]> arr(new int[4]{1, 2, 3, 4});

unique_ptr<int[]>ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ delete[]ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤


## ğŸ§° ì»¤ìŠ¤í…€ deleter ì‚¬ìš©
struct ArrayDeleter {
    template <class T>
    void operator()(T* p) {
        delete[] p;
    }
};

std::unique_ptr<int[], ArrayDeleter> ptr(new int[4]{1, 2, 3, 4});


ì»¤ìŠ¤í…€ deleterë¥¼ í†µí•´ ë‹¤ì–‘í•œ ìì› í•´ì œ ë°©ì‹ êµ¬í˜„ ê°€ëŠ¥


## âœ… ìš”ì•½
- unique_ptrì€ ìœ ì¼í•œ ì†Œìœ ê¶Œì„ ê°–ëŠ” ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°
- ì˜ˆì™¸ ì•ˆì „ì„±ê³¼ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€
- get(), release(), reset() ë“±ìœ¼ë¡œ ì„¸ë°€í•œ ì œì–´ ê°€ëŠ¥
- ì»¨í…Œì´ë„ˆ, ë°°ì—´, ì»¤ìŠ¤í…€ deleterê¹Œì§€ í­ë„“ê²Œ í™œìš© ê°€ëŠ¥

---


## ğŸ§  Smart Pointer Example: Building Triangles with `std::unique_ptr`

This example demonstrates how to use `std::unique_ptr` in C++ to manage dynamic memory safely and efficiently. It builds a simple 3D mesh composed of triangles using a builder pattern and smart pointers.

---

## ğŸ“¦ Overview

We define three main components:

- `Vector3D`: Represents a 3D point.
- `Triangle`: Composed of three `Vector3D` points.
- `Mesh`: Holds a collection of dynamically allocated `Triangle` objects using `std::unique_ptr`.

The `TriangleBuilder` class uses `std::optional` to ensure all three points are set before constructing a triangle.

---

## ğŸ§  Why Use `std::unique_ptr`?

`std::unique_ptr` is a smart pointer that owns and manages a dynamically allocated object. It ensures:

- **Automatic memory cleanup** when the pointer goes out of scope.
- **No memory leaks**.
- **Exclusive ownership**â€”you can't copy a `unique_ptr`, only move it.

This makes it ideal for managing resources like dynamically created `Triangle` objects.

---

## ğŸ§± Code Structure

### `Vector3D`

```cpp
struct Vector3D {
    float x, y, z;
    Vector3D(float x, float y, float z) : x(x), y(y), z(z) {}
};

Triangle
class Triangle {
public:
    Vector3D a, b, c;
    Triangle(Vector3D a, Vector3D b, Vector3D c)
        : a(a), b(b), c(c) {}
};


TriangleBuilder
class TriangleBuilder {
    std::optional<Vector3D> a, b, c;

public:
    TriangleBuilder& setA(float x, float y, float z);
    TriangleBuilder& setB(float x, float y, float z);
    TriangleBuilder& setC(float x, float y, float z);

    std::unique_ptr<Triangle> build(); // Throws if any point is missing
};


Mesh
class Mesh {
    std::vector<std::unique_ptr<Triangle>> triangles;

public:
    void addTriangle(std::unique_ptr<Triangle> tri);
    void print() const;
};
```


## ğŸš€ Example Usage
```cpp
int main() {
    Mesh mesh;

    auto triangle = TriangleBuilder()
                        .setA(0, 0, 0)
                        .setB(1, 0, 0)
                        .setC(0, 1, 0)
                        .build();

    mesh.addTriangle(std::move(triangle));
    mesh.print();
}
```

## ğŸ–¨ï¸ Output
```
Triangle: (0,0,0) - (1,0,0) - (0,1,0)
```


## âœ… Benefits of This Design
- Safe memory management with std::unique_ptr
- Clear construction logic using the builder pattern
- Extensible mesh structure for future enhancements

## ğŸ“š Requirements
- C++17 or later (for std::optional)
- Standard headers:
- <iostream>
- <optional>
- <memory>
- <stdexcept>
- <vector>

## ğŸ§µ Next Steps
You could extend this project by:
- Adding validation for triangle geometry
- Supporting more shapes (e.g., quads)
- Exporting mesh data to a file

---
