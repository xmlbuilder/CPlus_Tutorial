
# 📌 C++ 스마트 포인터: `unique_ptr` 완전 정복

C++에서 동적 메모리를 안전하게 관리하기 위한 도구 중 하나가 바로 `unique_ptr`입니다.  
이 문서에서는 `unique_ptr`의 철학, 사용법, 주의점, 실전 예제까지 모두 다룹니다.

---

## 🧠 스마트 포인터란?

스마트 포인터는 일반 포인터처럼 동작하지만, **자원 해제를 자동으로 처리**해주는 포인터 객체입니다.  
C++에서는 자원 관리 철학으로 **RAII (Resource Acquisition Is Initialization)**를 따릅니다.

> RAII란 객체가 생성될 때 자원을 획득하고, 객체가 소멸될 때 자원을 해제하는 패턴입니다.  
> 예외가 발생해도 스택에 있는 객체들은 자동으로 소멸됩니다 (stack unwinding).

---

## 🔐 `unique_ptr`의 핵심 개념

- 특정 객체의 **유일한 소유권**을 갖는 스마트 포인터
- `unique_ptr`이 소멸되면, **가리키던 객체도 자동으로 delete**
- 복사 생성자/복사 대입 연산자가 **삭제되어 있음**
- 소유권을 **이동하려면 `std::move()` 사용**

```cpp
std::unique_ptr<int> p(new int(99));
std::cout << *p << std::endl; // 99
```


## ⚠️ 일반 포인터의 위험성
```cpp
Data* data = new Data();
Data* data2 = data;
delete data;
delete data2; // ❌ 이미 해제된 메모리를 다시 delete → double free 오류 발생
```

unique_ptr은 이런 문제를 방지하기 위해 소유권을 명확히 정의합니다.


🛠️ 주요 멤버 함수
| 함수 | 설명 | 주의점 |
|-----|-----|-------| 
| get() | 내부 포인터 반환 | 소유권 유지 | 
| release() | 소유권 포기, 포인터 반환 | 반환된 포인터는 수동 delete 필요 | 
| reset() | 기존 객체 삭제, 새 객체 설정 | 자동 delete 수행 | 
| std::move() | 소유권 이전 | 원본은 nullptr로 설정됨 | 



## 📦 함수 인자로 전달하기

```cpp
void sub_do_something(UniquePtrTest* ptr) {
    ptr->some();
}

std::unique_ptr<UniquePtrTest> pa(new UniquePtrTest());
sub_do_something(pa.get()); // get()으로 내부 포인터 전달
```


객체에 접근은 가능하지만, 소유권은 유지됩니다

🚀 std::make_unique (C++14 이상)
auto ptr = std::make_unique<Foo>(3, 5);
ptr->print();

new 없이 안전하게 unique_ptr 생성 가능


## 📚 컨테이너와 함께 사용하기

```cpp
std::vector<std::unique_ptr<A>> vec;
vec.emplace_back(new A(1));
vec.back()->some();
```

push_back은 복사 생성자가 없어서 사용 불가 → emplace_back 사용


## 🧹 reset()과 release() 예제
std::unique_ptr<TestStuff> ptr(new TestStuff{3, "Hello"});
ptr.reset(); // 메모리 해제 후 nullptr로 설정

TestStuff* raw = ptr.release(); // 소유권 포기
delete raw; // 반드시 수동 delete 필요



## 🔄 소유권 이동: std::move
```cpp
auto ptr1 = std::make_unique<TestStuff>(3, "Hello");
auto ptr2 = std::move(ptr1); // ptr1은 nullptr
```

unique_ptr은 복사 불가, 반드시 std::move()로 소유권 이전


## 🧮 배열 처리
std::unique_ptr<int[]> arr(new int[4]{1, 2, 3, 4});

unique_ptr<int[]>는 내부적으로 delete[]를 호출합니다


## 🧰 커스텀 deleter 사용
struct ArrayDeleter {
    template <class T>
    void operator()(T* p) {
        delete[] p;
    }
};

std::unique_ptr<int[], ArrayDeleter> ptr(new int[4]{1, 2, 3, 4});


커스텀 deleter를 통해 다양한 자원 해제 방식 구현 가능


## ✅ 요약
- unique_ptr은 유일한 소유권을 갖는 스마트 포인터
- 예외 안전성과 메모리 누수를 방지
- get(), release(), reset() 등으로 세밀한 제어 가능
- 컨테이너, 배열, 커스텀 deleter까지 폭넓게 활용 가능

---


## 🧠 Smart Pointer Example: Building Triangles with `std::unique_ptr`

This example demonstrates how to use `std::unique_ptr` in C++ to manage dynamic memory safely and efficiently. It builds a simple 3D mesh composed of triangles using a builder pattern and smart pointers.

---

## 📦 Overview

We define three main components:

- `Vector3D`: Represents a 3D point.
- `Triangle`: Composed of three `Vector3D` points.
- `Mesh`: Holds a collection of dynamically allocated `Triangle` objects using `std::unique_ptr`.

The `TriangleBuilder` class uses `std::optional` to ensure all three points are set before constructing a triangle.

---

## 🧠 Why Use `std::unique_ptr`?

`std::unique_ptr` is a smart pointer that owns and manages a dynamically allocated object. It ensures:

- **Automatic memory cleanup** when the pointer goes out of scope.
- **No memory leaks**.
- **Exclusive ownership**—you can't copy a `unique_ptr`, only move it.

This makes it ideal for managing resources like dynamically created `Triangle` objects.

---

## 🧱 Code Structure

### `Vector3D`

```cpp
struct Vector3D {
    float x, y, z;
    Vector3D(float x, float y, float z) : x(x), y(y), z(z) {}
};

Triangle
class Triangle {
public:
    Vector3D a, b, c;
    Triangle(Vector3D a, Vector3D b, Vector3D c)
        : a(a), b(b), c(c) {}
};


TriangleBuilder
class TriangleBuilder {
    std::optional<Vector3D> a, b, c;

public:
    TriangleBuilder& setA(float x, float y, float z);
    TriangleBuilder& setB(float x, float y, float z);
    TriangleBuilder& setC(float x, float y, float z);

    std::unique_ptr<Triangle> build(); // Throws if any point is missing
};


Mesh
class Mesh {
    std::vector<std::unique_ptr<Triangle>> triangles;

public:
    void addTriangle(std::unique_ptr<Triangle> tri);
    void print() const;
};
```


## 🚀 Example Usage
```cpp
int main() {
    Mesh mesh;

    auto triangle = TriangleBuilder()
                        .setA(0, 0, 0)
                        .setB(1, 0, 0)
                        .setC(0, 1, 0)
                        .build();

    mesh.addTriangle(std::move(triangle));
    mesh.print();
}
```

## 🖨️ Output
```
Triangle: (0,0,0) - (1,0,0) - (0,1,0)
```


## ✅ Benefits of This Design
- Safe memory management with std::unique_ptr
- Clear construction logic using the builder pattern
- Extensible mesh structure for future enhancements

## 📚 Requirements
- C++17 or later (for std::optional)
- Standard headers:
- <iostream>
- <optional>
- <memory>
- <stdexcept>
- <vector>

## 🧵 Next Steps
You could extend this project by:
- Adding validation for triangle geometry
- Supporting more shapes (e.g., quads)
- Exporting mesh data to a file

---
