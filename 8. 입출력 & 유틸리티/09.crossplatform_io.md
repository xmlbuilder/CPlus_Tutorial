
# 📘 크로스 플랫폼 파일 I/O 실수 방지 가이드 (C++ 기준)

## 🧭 개요
크로스 플랫폼 개발에서 파일 입출력은 예상치 못한 버그의 온상이 될 수 있습니다.
특히 Windows와 Linux는 텍스트 처리 방식, 줄바꿈 문자, 파일 모드에 차이가 있어
동일한 코드가 한쪽에서는 잘 작동하고, 다른 쪽에서는 깨지는 일이 흔합니다.
이 가이드는 실전에서 자주 발생하는 I/O 실수를 예방하고,
운영체제 간 호환성을 확보하는 방법을 정리합니다.

## 🔍 1. 텍스트 모드 vs 바이너리 모드
| 모드 | 의미 | 줄바꿈 처리 | 용도 |
|------|-----|------------|-----| 
| "wt" | write text | \n → \r\n (Windows) | 텍스트 파일 | 
| "wb" | write binary | 그대로 저장 | 바이너리 파일 | 


## ✅ 권장 사항
- 바이너리 파일은 반드시 "wb"로 열기
- 텍스트 파일이라도 줄바꿈이 중요한 경우 "wb"로 열고 직접 제어
- 크로스 플랫폼 환경에서는 "wb"가 더 안전함

## ⚠️ 2. 줄바꿈 문자 차이
| OS | 줄바꿈 문자 |
|----|------------| 
| Linux / macOS | \n | 
| Windows | \r\n | 


## 문제 예시
- "wt" 모드에서 \n을 저장하면 Windows에서는 \r\n으로 변환됨
- 바이너리 데이터에 \n이 포함되면, Windows에서 자동 변환되어 데이터 손상 발생

## 🧠 3. 실수 사례
```cpp
FILE* fp = fopen("data.bin", "wt"); // ❌ 텍스트 모드로 바이너리 파일 열기
fwrite(buffer, 1, size, fp);        // 줄바꿈 변환으로 데이터 깨짐
```

해결 방법
```cpp
FILE* fp = fopen("data.bin", "wb"); // ✅ 바이너리 모드로 정확하게 저장
```


## 🔐 4. 인코딩 문제
- Windows는 기본적으로 UTF-16 또는 CP949를 사용하는 경우가 있음
- Linux/macOS는 대부분 UTF-8
- 텍스트 파일을 교환할 경우, 인코딩을 명시적으로 지정하거나 변환 필요
권장
- 모든 텍스트 파일은 UTF-8로 통일
- BOM(Byte Order Mark) 여부도 확인

## 🧪 5. 파일 경로 차이
| OS | 경로 구분자 |
|-----|-----------| 
| Windows | \ | 
| Linux/macOS | / | 


해결 방법
- 경로는 항상 / 사용 → Windows에서도 인식 가능
- 또는 std::filesystem 사용 (C++17 이상)
```cpp
std::filesystem::path filePath = "data/output.txt";
```


## 🧰 6. 크로스 플랫폼 안전 파일 열기 함수
```cpp
std::ofstream openBinaryWrite(const std::string& path) {
    std::ofstream ofs(path, std::ios::binary | std::ios::out);
    if (!ofs) throw std::runtime_error("파일 열기 실패: " + path);
    return ofs;
}
```


## ✅ 체크리스트
- [ ] 바이너리 파일은 "wb"로 열었는가?
- [ ] 줄바꿈 변환이 필요한가, 직접 처리할 것인가?
- [ ] 인코딩은 UTF-8로 통일했는가?
- [ ] 경로 구분자는 /로 통일했는가?
- [ ] 파일 모드는 명확하게 지정했는가?
- [ ] 운영체제별 테스트를 수행했는가?

## 🧭 마무리
파일 I/O는 단순해 보이지만, 운영체제의 기본 처리 방식에 따라
예상치 못한 버그와 데이터 손상이 발생할 수 있습니다.
---

