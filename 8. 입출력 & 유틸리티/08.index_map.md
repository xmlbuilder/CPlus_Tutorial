# 🧩 프로젝트 설명
## 📌 개요
이 프로젝트는 std::multimap을 사용하여 2차원 인덱스를 기반으로 객체를 저장하고, 페이지 단위로 데이터를 조회하는 구조를 구현한 예제입니다.  INDEX2 클래스를 키로 사용하여 정렬된 데이터를 관리하며, ChartVirtualManager를 통해 페이징된 데이터를 효율적으로 조회할 수 있습니다.




## 📄 주요 클래스 설명
### 🔹 DrawObject
- 단순한 인덱스를 가진 렌더링 객체
```cpp
class DrawObject {
public:
    DrawObject(int index) : index(index) {}
    int index = 0;
};
```

### 🔹 INDEX2
- 2차원 인덱스를 표현하는 키 클래스
- operator<를 오버라이드하여 std::multimap에서 정렬 기준 제공
```cpp
class INDEX2 {
public:
    INDEX2(int i, int j) { ijk[0] = i; ijk[1] = j; }
    int ijk[2];
    inline bool operator < (const INDEX2& rhs) const {
        return (ijk[0] == rhs.ijk[0]) ? (ijk[1] < rhs.ijk[1]) : (ijk[0] < rhs.ijk[0]);
    }
};
```

### 🔹 ChartVirtualManager
- DrawObject들을 INDEX2 키로 저장
- 페이지 단위로 데이터를 조회하는 기능 제공
```cpp
class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol);
    void addChartData(int iRow, int iCol, DrawObject *pDrawObj);
    std::multimap<INDEX2, DrawObject*> getCharts(int iPage) const;
    int getPossiblePage() const;
    int getRow() const;
    int getCol() const;

protected:
    std::multimap<INDEX2, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow;
    int m_nCol;
};
```

## 전체 소스
```cpp
#include <functional>
#include <iostream>
#include <map>

class DrawObject {
public:
    DrawObject(int index) {
        this->index = index;
    }
    int index = 0;
};

class INDEX2
{
public:
    INDEX2(int i, int j)
    {
        ijk[0] = i;
        ijk[1] = j;
    }
    int ijk[2];
    inline bool operator < (const INDEX2& rhs) const
    {
        if (ijk[0] == rhs.ijk[0])
        {
            return (ijk[1] < rhs.ijk[1]);
        }
        else
        {
            return (ijk[0] < rhs.ijk[0]);
        }
    }
};

static DrawObject DrawObjects[4*4] = {
    DrawObject(0),
    DrawObject(1),
    DrawObject(2),
    DrawObject(3),
    DrawObject(4),
    DrawObject(5),
    DrawObject(6),
    DrawObject(7),
    DrawObject(8),
    DrawObject(9),
    DrawObject(10),
    DrawObject(11),
    DrawObject(12),
    DrawObject(13),
    DrawObject(14),
    DrawObject(15),
};

class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol) {
        this->m_nRow = iRow;
        this->m_nCol = iCol;
    }

    void addChartData(int iRow, int iCol, DrawObject *pDrawObj) {
        INDEX2 index(iRow, iCol);
        drawObjects.insert(std::pair<INDEX2, DrawObject*>(index, pDrawObj));
    }

    [[nodiscard]] int getPossiblePage() const {
        int iPage = m_nMaxRow * m_nMaxCol / (m_nRow * m_nCol);
        if ( m_nMaxRow * m_nMaxCol % (m_nRow * m_nCol) != 0) iPage++;
        return iPage;
    }

    [[nodiscard]] std::multimap<INDEX2, DrawObject*> getCharts(int iPage) const {
        std::multimap<INDEX2, DrawObject*> result;
        int nSize = m_nRow * m_nCol;
        int nStart = iPage * nSize;
        for (int i = 0; i <  nSize; i++) {
            int index = nStart + i;
            int nRowIndex = index / m_nMaxRow;
            int nColIndex = index % m_nMaxRow;
            if (nRowIndex < m_nMaxCol && nColIndex < m_nMaxCol) {
                INDEX2 findIndex = INDEX2(nRowIndex, nColIndex);
                for (auto itr = drawObjects.lower_bound(findIndex); itr != drawObjects.upper_bound(findIndex); itr++) {
                    DrawObject *pDrawObj = itr->second;
                    INDEX2 retIndex = INDEX2(i / m_nCol, i % m_nCol);
                    result.insert(std::pair<INDEX2, DrawObject*>(retIndex, pDrawObj));
                    std::cout << retIndex.ijk[0] << " " << retIndex.ijk[1] << std::endl;
                }
            }
        }
        return result;
    }
    [[nodiscard]] int getRow() const { return m_nRow; }
    [[nodiscard]] int getCol() const { return m_nCol; }
protected:
    std::multimap<INDEX2, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow = 4;
    int m_nCol = 4;
};

int main() {
    ChartVirtualManager chartVirtualManager(4, 4);
    chartVirtualManager.addChartData(0, 0, &DrawObjects[4*0+0]);
    chartVirtualManager.addChartData(0, 1, &DrawObjects[4*0+1]);
    chartVirtualManager.addChartData(0, 2, &DrawObjects[4*0+2]);
    chartVirtualManager.addChartData(0, 3, &DrawObjects[4*0+3]);
    chartVirtualManager.addChartData(1, 0, &DrawObjects[4*1+0]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*1+1]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*0+1]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*0+2]);
    chartVirtualManager.addChartData(1, 2, &DrawObjects[4*1+2]);
    chartVirtualManager.addChartData(1, 3, &DrawObjects[4*1+3]);
    chartVirtualManager.addChartData(2, 0, &DrawObjects[4*2+0]);
    chartVirtualManager.addChartData(2, 1, &DrawObjects[4*2+1]);
    chartVirtualManager.addChartData(2, 2, &DrawObjects[4*2+2]);
    chartVirtualManager.addChartData(2, 3, &DrawObjects[4*2+3]);
    chartVirtualManager.addChartData(3, 0, &DrawObjects[4*3+0]);
    chartVirtualManager.addChartData(3, 1, &DrawObjects[4*3+1]);
    chartVirtualManager.addChartData(3, 2, &DrawObjects[4*3+2]);
    chartVirtualManager.addChartData(3, 3, &DrawObjects[4*3+3]);
    int nPage = chartVirtualManager.getPossiblePage();
    int nRow = chartVirtualManager.getRow();
    int nCol = chartVirtualManager.getCol();

    for (int i =0; i<nPage; i++) {
        std::cout << "=======================================================" << std::endl;
        std::cout << "Page " << i << std::endl;
        std::multimap<INDEX2, DrawObject*> result = chartVirtualManager.getCharts(i);
        for (int j =0; j<nRow; j++) {
            for (int k=0; k<nCol; k++) {
                INDEX2 chartIndex = INDEX2(j, k);
                for (auto itr = result.lower_bound(chartIndex); itr != result.upper_bound(chartIndex); itr++) {
                    DrawObject *pDrawObj = itr->second;
                    std::cout << "J : " << j << " K : " << k << " Index : "  << pDrawObj->index << std::endl;
                }
            }
        }
    }
    std::cout << "=======================================================" << std::endl;
    return 0;
}

```


## 🧪 실행 예시
$ g++ -std=c++17 main.cpp -o drawmap
$ ./drawmap

```
Page 0
J : 0 K : 0 Index : 0
J : 0 K : 1 Index : 1
...
```

## ✨ 개선 아이디어
- INDEX2를 std::tuple<int, int>로 대체하면 STL 기반 비교 연산을 활용할 수 있음
- DrawObject에 더 많은 속성 추가 (예: 색상, 이름 등)
- ChartVirtualManager에 페이지 크기 동적 설정 기능 추가
- getCharts()를 std::vector<std::vector<DrawObject*>> 형태로 반환하면 UI 렌더링에 더 적합


---

## ✅ std::tuple 사용의 장점
### 1. 자동 비교 연산 지원
std::tuple은 <, == 등의 비교 연산자가 자동으로 정의되어 있어서 std::map이나 std::set의 키로 바로 사용할 수 있어요.
### 2. 코드 간결성
구조체를 따로 정의하지 않아도 되므로 코드가 짧고 명확해져요.
### 3. 유연한 타입 조합
std::tuple<int, int>뿐 아니라 std::tuple<int, std::string, double>처럼 다양한 타입을 조합할 수 있어요.

## 🔧 샘플 코드 비교
### 기존 방식 (INDEX2 사용)
```cpp
class INDEX2 {
public:
    int ijk[2];
    bool operator<(const INDEX2& rhs) const {
        return (ijk[0] == rhs.ijk[0]) ? (ijk[1] < rhs.ijk[1]) : (ijk[0] < rhs.ijk[0]);
    }
};
std::map<INDEX2, DrawObject*> drawObjects;
```

### 개선된 방식 (std::tuple 사용)
```cpp
#include <tuple>
#include <map>

std::map<std::tuple<int, int>, DrawObject*> drawObjects;

// 삽입 예시
drawObjects[{1, 2}] = new DrawObject(5);

// 조회 예시
auto it = drawObjects.find({1, 2});
if (it != drawObjects.end()) {
    std::cout << "Found: " << it->second->index << std::endl;
}
```


## ✨ 추가 팁
- std::get<0>(tuple)로 각 요소에 접근할 수 있어요.
- std::tie를 사용하면 비교나 분해도 쉽게 할 수 있어요.
```cpp
int x, y;
std::tie(x, y) = std::make_tuple(1, 2);
```

## tuple을 이용하여 변경된 소스


### 🔧 주요 변경 사항 요약
| 항목 | 기존 방식 (INDEX2) | 리팩토링 방식 (std::tuple<int, int>) |
|------|-------------------|-----------------------------------| 
| 인덱스 표현 | 사용자 정의 클래스 | STL의 std::tuple 사용 | 
| 비교 연산 | operator< 직접 구현 | 자동 제공되는 비교 연산 | 
| 코드 길이 | 다소 장황함 | 간결하고 직관적 | 



### 🧼 리팩토링된 코드 예시
```cpp
#include <iostream>
#include <map>
#include <tuple>

class DrawObject {
public:
    DrawObject(int index) : index(index) {}
    int index = 0;
};

static DrawObject DrawObjects[16] = {
    DrawObject(0), DrawObject(1), DrawObject(2), DrawObject(3),
    DrawObject(4), DrawObject(5), DrawObject(6), DrawObject(7),
    DrawObject(8), DrawObject(9), DrawObject(10), DrawObject(11),
    DrawObject(12), DrawObject(13), DrawObject(14), DrawObject(15),
};

class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol) : m_nRow(iRow), m_nCol(iCol) {}

    void addChartData(int iRow, int iCol, DrawObject* pDrawObj) {
        drawObjects.insert({ std::make_tuple(iRow, iCol), pDrawObj });
    }

    int getPossiblePage() const {
        int total = m_nMaxRow * m_nMaxCol;
        int perPage = m_nRow * m_nCol;
        return (total + perPage - 1) / perPage;
    }

    std::multimap<std::tuple<int, int>, DrawObject*> getCharts(int iPage) const {
        std::multimap<std::tuple<int, int>, DrawObject*> result;
        int nSize = m_nRow * m_nCol;
        int nStart = iPage * nSize;

        for (int i = 0; i < nSize; ++i) {
            int index = nStart + i;
            int row = index / m_nMaxRow;
            int col = index % m_nMaxRow;

            if (row < m_nMaxCol && col < m_nMaxCol) {
                auto range = drawObjects.equal_range(std::make_tuple(row, col));
                for (auto it = range.first; it != range.second; ++it) {
                    int localRow = i / m_nCol;
                    int localCol = i % m_nCol;
                    result.insert({ std::make_tuple(localRow, localCol), it->second });
                }
            }
        }
        return result;
    }

    int getRow() const { return m_nRow; }
    int getCol() const { return m_nCol; }

private:
    std::multimap<std::tuple<int, int>, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow;
    int m_nCol;
};

int main() {
    ChartVirtualManager manager(4, 4);

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            manager.addChartData(i, j, &DrawObjects[i * 4 + j]);

    // 중복 추가 테스트
    manager.addChartData(1, 1, &DrawObjects[1]);
    manager.addChartData(1, 1, &DrawObjects[2]);

    int pages = manager.getPossiblePage();
    for (int p = 0; p < pages; ++p) {
        std::cout << "================ Page " << p << " ================\n";
        auto charts = manager.getCharts(p);
        for (int r = 0; r < manager.getRow(); ++r) {
            for (int c = 0; c < manager.getCol(); ++c) {
                auto range = charts.equal_range(std::make_tuple(r, c));
                for (auto it = range.first; it != range.second; ++it) {
                    std::cout << "Row: " << r << " Col: " << c
                              << " Index: " << it->second->index << "\n";
                }
            }
        }
    }
    return 0;
}
```

### ✨ 리팩토링 효과
- INDEX2 클래스 제거 → 코드 간결화
- STL의 비교 연산 활용 → 안정성과 유지보수 향상
- std::tuple 기반 → 다양한 인덱스 구조로 확장 가능

---


