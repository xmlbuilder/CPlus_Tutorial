# ğŸ§© í”„ë¡œì íŠ¸ ì„¤ëª…
## ğŸ“Œ ê°œìš”
ì´ í”„ë¡œì íŠ¸ëŠ” std::multimapì„ ì‚¬ìš©í•˜ì—¬ 2ì°¨ì› ì¸ë±ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê°ì²´ë¥¼ ì €ì¥í•˜ê³ , í˜ì´ì§€ ë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ëŠ” êµ¬ì¡°ë¥¼ êµ¬í˜„í•œ ì˜ˆì œì…ë‹ˆë‹¤.  INDEX2 í´ë˜ìŠ¤ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ì—¬ ì •ë ¬ëœ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ë©°, ChartVirtualManagerë¥¼ í†µí•´ í˜ì´ì§•ëœ ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.




## ğŸ“„ ì£¼ìš” í´ë˜ìŠ¤ ì„¤ëª…
### ğŸ”¹ DrawObject
- ë‹¨ìˆœí•œ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ ë Œë”ë§ ê°ì²´
```cpp
class DrawObject {
public:
    DrawObject(int index) : index(index) {}
    int index = 0;
};
```

### ğŸ”¹ INDEX2
- 2ì°¨ì› ì¸ë±ìŠ¤ë¥¼ í‘œí˜„í•˜ëŠ” í‚¤ í´ë˜ìŠ¤
- operator<ë¥¼ ì˜¤ë²„ë¼ì´ë“œí•˜ì—¬ std::multimapì—ì„œ ì •ë ¬ ê¸°ì¤€ ì œê³µ
```cpp
class INDEX2 {
public:
    INDEX2(int i, int j) { ijk[0] = i; ijk[1] = j; }
    int ijk[2];
    inline bool operator < (const INDEX2& rhs) const {
        return (ijk[0] == rhs.ijk[0]) ? (ijk[1] < rhs.ijk[1]) : (ijk[0] < rhs.ijk[0]);
    }
};
```

### ğŸ”¹ ChartVirtualManager
- DrawObjectë“¤ì„ INDEX2 í‚¤ë¡œ ì €ì¥
- í˜ì´ì§€ ë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ëŠ” ê¸°ëŠ¥ ì œê³µ
```cpp
class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol);
    void addChartData(int iRow, int iCol, DrawObject *pDrawObj);
    std::multimap<INDEX2, DrawObject*> getCharts(int iPage) const;
    int getPossiblePage() const;
    int getRow() const;
    int getCol() const;

protected:
    std::multimap<INDEX2, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow;
    int m_nCol;
};
```

## ì „ì²´ ì†ŒìŠ¤
```cpp
#include <functional>
#include <iostream>
#include <map>

class DrawObject {
public:
    DrawObject(int index) {
        this->index = index;
    }
    int index = 0;
};

class INDEX2
{
public:
    INDEX2(int i, int j)
    {
        ijk[0] = i;
        ijk[1] = j;
    }
    int ijk[2];
    inline bool operator < (const INDEX2& rhs) const
    {
        if (ijk[0] == rhs.ijk[0])
        {
            return (ijk[1] < rhs.ijk[1]);
        }
        else
        {
            return (ijk[0] < rhs.ijk[0]);
        }
    }
};

static DrawObject DrawObjects[4*4] = {
    DrawObject(0),
    DrawObject(1),
    DrawObject(2),
    DrawObject(3),
    DrawObject(4),
    DrawObject(5),
    DrawObject(6),
    DrawObject(7),
    DrawObject(8),
    DrawObject(9),
    DrawObject(10),
    DrawObject(11),
    DrawObject(12),
    DrawObject(13),
    DrawObject(14),
    DrawObject(15),
};

class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol) {
        this->m_nRow = iRow;
        this->m_nCol = iCol;
    }

    void addChartData(int iRow, int iCol, DrawObject *pDrawObj) {
        INDEX2 index(iRow, iCol);
        drawObjects.insert(std::pair<INDEX2, DrawObject*>(index, pDrawObj));
    }

    [[nodiscard]] int getPossiblePage() const {
        int iPage = m_nMaxRow * m_nMaxCol / (m_nRow * m_nCol);
        if ( m_nMaxRow * m_nMaxCol % (m_nRow * m_nCol) != 0) iPage++;
        return iPage;
    }

    [[nodiscard]] std::multimap<INDEX2, DrawObject*> getCharts(int iPage) const {
        std::multimap<INDEX2, DrawObject*> result;
        int nSize = m_nRow * m_nCol;
        int nStart = iPage * nSize;
        for (int i = 0; i <  nSize; i++) {
            int index = nStart + i;
            int nRowIndex = index / m_nMaxRow;
            int nColIndex = index % m_nMaxRow;
            if (nRowIndex < m_nMaxCol && nColIndex < m_nMaxCol) {
                INDEX2 findIndex = INDEX2(nRowIndex, nColIndex);
                for (auto itr = drawObjects.lower_bound(findIndex); itr != drawObjects.upper_bound(findIndex); itr++) {
                    DrawObject *pDrawObj = itr->second;
                    INDEX2 retIndex = INDEX2(i / m_nCol, i % m_nCol);
                    result.insert(std::pair<INDEX2, DrawObject*>(retIndex, pDrawObj));
                    std::cout << retIndex.ijk[0] << " " << retIndex.ijk[1] << std::endl;
                }
            }
        }
        return result;
    }
    [[nodiscard]] int getRow() const { return m_nRow; }
    [[nodiscard]] int getCol() const { return m_nCol; }
protected:
    std::multimap<INDEX2, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow = 4;
    int m_nCol = 4;
};

int main() {
    ChartVirtualManager chartVirtualManager(4, 4);
    chartVirtualManager.addChartData(0, 0, &DrawObjects[4*0+0]);
    chartVirtualManager.addChartData(0, 1, &DrawObjects[4*0+1]);
    chartVirtualManager.addChartData(0, 2, &DrawObjects[4*0+2]);
    chartVirtualManager.addChartData(0, 3, &DrawObjects[4*0+3]);
    chartVirtualManager.addChartData(1, 0, &DrawObjects[4*1+0]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*1+1]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*0+1]);
    chartVirtualManager.addChartData(1, 1, &DrawObjects[4*0+2]);
    chartVirtualManager.addChartData(1, 2, &DrawObjects[4*1+2]);
    chartVirtualManager.addChartData(1, 3, &DrawObjects[4*1+3]);
    chartVirtualManager.addChartData(2, 0, &DrawObjects[4*2+0]);
    chartVirtualManager.addChartData(2, 1, &DrawObjects[4*2+1]);
    chartVirtualManager.addChartData(2, 2, &DrawObjects[4*2+2]);
    chartVirtualManager.addChartData(2, 3, &DrawObjects[4*2+3]);
    chartVirtualManager.addChartData(3, 0, &DrawObjects[4*3+0]);
    chartVirtualManager.addChartData(3, 1, &DrawObjects[4*3+1]);
    chartVirtualManager.addChartData(3, 2, &DrawObjects[4*3+2]);
    chartVirtualManager.addChartData(3, 3, &DrawObjects[4*3+3]);
    int nPage = chartVirtualManager.getPossiblePage();
    int nRow = chartVirtualManager.getRow();
    int nCol = chartVirtualManager.getCol();

    for (int i =0; i<nPage; i++) {
        std::cout << "=======================================================" << std::endl;
        std::cout << "Page " << i << std::endl;
        std::multimap<INDEX2, DrawObject*> result = chartVirtualManager.getCharts(i);
        for (int j =0; j<nRow; j++) {
            for (int k=0; k<nCol; k++) {
                INDEX2 chartIndex = INDEX2(j, k);
                for (auto itr = result.lower_bound(chartIndex); itr != result.upper_bound(chartIndex); itr++) {
                    DrawObject *pDrawObj = itr->second;
                    std::cout << "J : " << j << " K : " << k << " Index : "  << pDrawObj->index << std::endl;
                }
            }
        }
    }
    std::cout << "=======================================================" << std::endl;
    return 0;
}

```


## ğŸ§ª ì‹¤í–‰ ì˜ˆì‹œ
$ g++ -std=c++17 main.cpp -o drawmap
$ ./drawmap

```
Page 0
J : 0 K : 0 Index : 0
J : 0 K : 1 Index : 1
...
```

## âœ¨ ê°œì„  ì•„ì´ë””ì–´
- INDEX2ë¥¼ std::tuple<int, int>ë¡œ ëŒ€ì²´í•˜ë©´ STL ê¸°ë°˜ ë¹„êµ ì—°ì‚°ì„ í™œìš©í•  ìˆ˜ ìˆìŒ
- DrawObjectì— ë” ë§ì€ ì†ì„± ì¶”ê°€ (ì˜ˆ: ìƒ‰ìƒ, ì´ë¦„ ë“±)
- ChartVirtualManagerì— í˜ì´ì§€ í¬ê¸° ë™ì  ì„¤ì • ê¸°ëŠ¥ ì¶”ê°€
- getCharts()ë¥¼ std::vector<std::vector<DrawObject*>> í˜•íƒœë¡œ ë°˜í™˜í•˜ë©´ UI ë Œë”ë§ì— ë” ì í•©


---

## âœ… std::tuple ì‚¬ìš©ì˜ ì¥ì 
### 1. ìë™ ë¹„êµ ì—°ì‚° ì§€ì›
std::tupleì€ <, == ë“±ì˜ ë¹„êµ ì—°ì‚°ìê°€ ìë™ìœ¼ë¡œ ì •ì˜ë˜ì–´ ìˆì–´ì„œ std::mapì´ë‚˜ std::setì˜ í‚¤ë¡œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ìš”.
### 2. ì½”ë“œ ê°„ê²°ì„±
êµ¬ì¡°ì²´ë¥¼ ë”°ë¡œ ì •ì˜í•˜ì§€ ì•Šì•„ë„ ë˜ë¯€ë¡œ ì½”ë“œê°€ ì§§ê³  ëª…í™•í•´ì ¸ìš”.
### 3. ìœ ì—°í•œ íƒ€ì… ì¡°í•©
std::tuple<int, int>ë¿ ì•„ë‹ˆë¼ std::tuple<int, std::string, double>ì²˜ëŸ¼ ë‹¤ì–‘í•œ íƒ€ì…ì„ ì¡°í•©í•  ìˆ˜ ìˆì–´ìš”.

## ğŸ”§ ìƒ˜í”Œ ì½”ë“œ ë¹„êµ
### ê¸°ì¡´ ë°©ì‹ (INDEX2 ì‚¬ìš©)
```cpp
class INDEX2 {
public:
    int ijk[2];
    bool operator<(const INDEX2& rhs) const {
        return (ijk[0] == rhs.ijk[0]) ? (ijk[1] < rhs.ijk[1]) : (ijk[0] < rhs.ijk[0]);
    }
};
std::map<INDEX2, DrawObject*> drawObjects;
```

### ê°œì„ ëœ ë°©ì‹ (std::tuple ì‚¬ìš©)
```cpp
#include <tuple>
#include <map>

std::map<std::tuple<int, int>, DrawObject*> drawObjects;

// ì‚½ì… ì˜ˆì‹œ
drawObjects[{1, 2}] = new DrawObject(5);

// ì¡°íšŒ ì˜ˆì‹œ
auto it = drawObjects.find({1, 2});
if (it != drawObjects.end()) {
    std::cout << "Found: " << it->second->index << std::endl;
}
```


## âœ¨ ì¶”ê°€ íŒ
- std::get<0>(tuple)ë¡œ ê° ìš”ì†Œì— ì ‘ê·¼í•  ìˆ˜ ìˆì–´ìš”.
- std::tieë¥¼ ì‚¬ìš©í•˜ë©´ ë¹„êµë‚˜ ë¶„í•´ë„ ì‰½ê²Œ í•  ìˆ˜ ìˆì–´ìš”.
```cpp
int x, y;
std::tie(x, y) = std::make_tuple(1, 2);
```

## tupleì„ ì´ìš©í•˜ì—¬ ë³€ê²½ëœ ì†ŒìŠ¤


### ğŸ”§ ì£¼ìš” ë³€ê²½ ì‚¬í•­ ìš”ì•½
| í•­ëª© | ê¸°ì¡´ ë°©ì‹ (INDEX2) | ë¦¬íŒ©í† ë§ ë°©ì‹ (std::tuple<int, int>) |
|------|-------------------|-----------------------------------| 
| ì¸ë±ìŠ¤ í‘œí˜„ | ì‚¬ìš©ì ì •ì˜ í´ë˜ìŠ¤ | STLì˜ std::tuple ì‚¬ìš© | 
| ë¹„êµ ì—°ì‚° | operator< ì§ì ‘ êµ¬í˜„ | ìë™ ì œê³µë˜ëŠ” ë¹„êµ ì—°ì‚° | 
| ì½”ë“œ ê¸¸ì´ | ë‹¤ì†Œ ì¥í™©í•¨ | ê°„ê²°í•˜ê³  ì§ê´€ì  | 



### ğŸ§¼ ë¦¬íŒ©í† ë§ëœ ì½”ë“œ ì˜ˆì‹œ
```cpp
#include <iostream>
#include <map>
#include <tuple>

class DrawObject {
public:
    DrawObject(int index) : index(index) {}
    int index = 0;
};

static DrawObject DrawObjects[16] = {
    DrawObject(0), DrawObject(1), DrawObject(2), DrawObject(3),
    DrawObject(4), DrawObject(5), DrawObject(6), DrawObject(7),
    DrawObject(8), DrawObject(9), DrawObject(10), DrawObject(11),
    DrawObject(12), DrawObject(13), DrawObject(14), DrawObject(15),
};

class ChartVirtualManager {
public:
    ChartVirtualManager(int iRow, int iCol) : m_nRow(iRow), m_nCol(iCol) {}

    void addChartData(int iRow, int iCol, DrawObject* pDrawObj) {
        drawObjects.insert({ std::make_tuple(iRow, iCol), pDrawObj });
    }

    int getPossiblePage() const {
        int total = m_nMaxRow * m_nMaxCol;
        int perPage = m_nRow * m_nCol;
        return (total + perPage - 1) / perPage;
    }

    std::multimap<std::tuple<int, int>, DrawObject*> getCharts(int iPage) const {
        std::multimap<std::tuple<int, int>, DrawObject*> result;
        int nSize = m_nRow * m_nCol;
        int nStart = iPage * nSize;

        for (int i = 0; i < nSize; ++i) {
            int index = nStart + i;
            int row = index / m_nMaxRow;
            int col = index % m_nMaxRow;

            if (row < m_nMaxCol && col < m_nMaxCol) {
                auto range = drawObjects.equal_range(std::make_tuple(row, col));
                for (auto it = range.first; it != range.second; ++it) {
                    int localRow = i / m_nCol;
                    int localCol = i % m_nCol;
                    result.insert({ std::make_tuple(localRow, localCol), it->second });
                }
            }
        }
        return result;
    }

    int getRow() const { return m_nRow; }
    int getCol() const { return m_nCol; }

private:
    std::multimap<std::tuple<int, int>, DrawObject*> drawObjects;
    int m_nMaxRow = 4;
    int m_nMaxCol = 4;
    int m_nRow;
    int m_nCol;
};

int main() {
    ChartVirtualManager manager(4, 4);

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            manager.addChartData(i, j, &DrawObjects[i * 4 + j]);

    // ì¤‘ë³µ ì¶”ê°€ í…ŒìŠ¤íŠ¸
    manager.addChartData(1, 1, &DrawObjects[1]);
    manager.addChartData(1, 1, &DrawObjects[2]);

    int pages = manager.getPossiblePage();
    for (int p = 0; p < pages; ++p) {
        std::cout << "================ Page " << p << " ================\n";
        auto charts = manager.getCharts(p);
        for (int r = 0; r < manager.getRow(); ++r) {
            for (int c = 0; c < manager.getCol(); ++c) {
                auto range = charts.equal_range(std::make_tuple(r, c));
                for (auto it = range.first; it != range.second; ++it) {
                    std::cout << "Row: " << r << " Col: " << c
                              << " Index: " << it->second->index << "\n";
                }
            }
        }
    }
    return 0;
}
```

### âœ¨ ë¦¬íŒ©í† ë§ íš¨ê³¼
- INDEX2 í´ë˜ìŠ¤ ì œê±° â†’ ì½”ë“œ ê°„ê²°í™”
- STLì˜ ë¹„êµ ì—°ì‚° í™œìš© â†’ ì•ˆì •ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ í–¥ìƒ
- std::tuple ê¸°ë°˜ â†’ ë‹¤ì–‘í•œ ì¸ë±ìŠ¤ êµ¬ì¡°ë¡œ í™•ì¥ ê°€ëŠ¥

---


