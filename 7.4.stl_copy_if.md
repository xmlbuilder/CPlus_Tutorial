# copy_if Point3D Distance Filter ì— ì ìš©í•´ ë³´ê¸°

## ğŸ“Œ std::copy_ifë€?

`std::copy_if`ëŠ” C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ `<algorithm>`ì— í¬í•¨ëœ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ,  
**ì£¼ì–´ì§„ ë²”ìœ„ì—ì„œ ì¡°ê±´(Predicate)ì„ ë§Œì¡±í•˜ëŠ” ì›ì†Œë§Œ ë‹¤ë¥¸ ì»¨í…Œì´ë„ˆë¡œ ë³µì‚¬**í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

- **í˜•íƒœ**:
```cpp
template<class InputIt, class OutputIt, class UnaryPredicate>
OutputIt copy_if(InputIt first, InputIt last, OutputIt d_first, UnaryPredicate pred);
```
- **ë§¤ê°œë³€ìˆ˜**
  - `first`, `last` : ì…ë ¥ ë²”ìœ„
  - `d_first` : ë³µì‚¬í•  ëŒ€ìƒ ì»¨í…Œì´ë„ˆì˜ ì‹œì‘ ë°˜ë³µì
  - `pred` : ì›ì†Œë¥¼ ë³µì‚¬í• ì§€ ì—¬ë¶€ë¥¼ ê²°ì •í•˜ëŠ” ì¡°ê±´ í•¨ìˆ˜(ë˜ëŠ” ëŒë‹¤)
- **ë°˜í™˜ê°’** : ë§ˆì§€ë§‰ìœ¼ë¡œ ë³µì‚¬í•œ ì›ì†Œ ë‹¤ìŒ ìœ„ì¹˜ì˜ ì¶œë ¥ ë°˜ë³µì
- **íŠ¹ì§•**:
  - ì›ì†Œì˜ **ìˆœì„œë¥¼ ìœ ì§€**í•˜ë©´ì„œ ì¡°ê±´ì— ë§ëŠ” ê²ƒë§Œ ë³µì‚¬
  - ëŒ€ìƒ ì»¨í…Œì´ë„ˆëŠ” ë¯¸ë¦¬ í¬ê¸°ë¥¼ í™•ë³´í•´ ë‘ê±°ë‚˜, `std::back_inserter`ë¥¼ ì‚¬ìš©

âœ… **ê°„ë‹¨ ì˜ˆì‹œ**:
```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> src = {1, 2, 3, 4, 5};
    std::vector<int> dst;

    std::copy_if(src.begin(), src.end(), std::back_inserter(dst),
                 [](int x){ return x % 2 == 0; });

    for (int v : dst) std::cout << v << " "; // 2 4
}
```

---

## ğŸ“Œ ì´ ì˜ˆì œì—ì„œì˜ í™œìš©

ì´ í”„ë¡œì íŠ¸ì—ì„œëŠ” `std::copy_if`ë¥¼ ì‚¬ìš©í•´,  
ê¸°ì¤€ì (`center`)ì—ì„œ ì¼ì • ê±°ë¦¬(`threshold`) ì•ˆì— ìˆëŠ” 3D í¬ì¸íŠ¸ë§Œ ê±¸ëŸ¬ëƒ…ë‹ˆë‹¤.

## âœ¨ í•µì‹¬ í¬ì¸íŠ¸
- `Point3D::DistanceTo` : ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°
- `std::copy_if` + `std::back_inserter` : ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì›ì†Œë§Œ `filtered`ì— ë³µì‚¬
- ëŒë‹¤ ìº¡ì²˜ `[&]` : `center`ì™€ `threshold`ë¥¼ ëŒë‹¤ì—ì„œ ì‚¬ìš©
- ì‹œê°„ë³µì¡ë„: O(n)

## ğŸ§¾ ì½”ë“œ

```cpp
#include <vector>
#include <algorithm>
#include <cmath>
#include <iostream>

struct Point3D {
    double x, y, z;

    double DistanceTo(const Point3D& other) const {
        double dx = x - other.x;
        double dy = y - other.y;
        double dz = z - other.z;
        return std::sqrt(dx * dx + dy * dy + dz * dz);
    }
};

int main() {
    std::vector<Point3D> points = {
        {1, 2, 3}, {2, 3, 4}, {10, 10, 10}, {3, 4, 5}
    };

    Point3D center = {2, 3, 4};
    double threshold = 5.0;

    std::vector<Point3D> filtered;

    std::copy_if(points.begin(), points.end(), std::back_inserter(filtered),
        [&](const Point3D& p) {
            return p.DistanceTo(center) < threshold;
        });

    for (const auto& p : filtered) {
        std::cout << "Filtered Point: (" << p.x << ", " << p.y << ", " << p.z << ")\n";
    }

    return 0;
}
```

## â–¶ï¸ ë¹Œë“œ & ì‹¤í–‰

### g++
```bash
g++ -std=c++17 -O2 main.cpp -o filter_points
./filter_points
```

### (ì„ íƒ) CMake
`CMakeLists.txt`:
```cmake
cmake_minimum_required(VERSION 3.12)
project(Point3DFilter CXX)
set(CMAKE_CXX_STANDARD 17)
add_executable(filter_points main.cpp)
```
ë¹Œë“œ:
```bash
cmake -S . -B build
cmake --build build --config Release
./build/filter_points
```

## ğŸ§ª ì˜ˆìƒ ì¶œë ¥
```
Filtered Point: (1, 2, 3)
Filtered Point: (2, 3, 4)
Filtered Point: (3, 4, 5)
```

## ğŸ› ï¸ íŒ (ì„±ëŠ¥/ì•ˆì •ì„±)
- **sqrt ì—†ì´ ì œê³±ê±°ë¦¬ ë¹„êµ**ë¡œ ì„±ëŠ¥ ë¯¸ì„¸ ê°œì„ :
  ```cpp
  auto sqdist = [&](const Point3D& a, const Point3D& b){
      double dx=a.x-b.x, dy=a.y-b.y, dz=a.z-b.z;
      return dx*dx + dy*dy + dz*dz;
  };
  double thr2 = threshold * threshold;
  std::copy_if(points.begin(), points.end(), std::back_inserter(filtered),
               [&](const Point3D& p){ return sqdist(p, center) < thr2; });
  ```
- í° ë°ì´í„°ë¥¼ ë¯¸ë¦¬ ì˜ˆìƒí•œë‹¤ë©´ `filtered.reserve(points.size());`ë¡œ ì¬í• ë‹¹ ì¤„ì´ê¸°
- ì„ê³„ê°’ ê²½ê³„ í¬í•¨ ì—¬ë¶€ëŠ” ê¸°íšì— ë§ì¶° `<` vs `<=` ì„ íƒ
- NaN ì…ë ¥ ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë©´ `std::isfinite` ê²€ì‚¬ ì¶”ê°€ ê³ ë ¤

