# ğŸš€ TFastList: ê³ ì† ì»¤ìŠ¤í…€ ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ
## ğŸ“Œ ê°œìš”
TFastListëŠ” chunk ê¸°ë°˜ ë©”ëª¨ë¦¬ ë§¤ë‹ˆì €(CFixedAllocNoSync)ë¥¼ í™œìš©í•˜ì—¬ ë¹ ë¥¸ ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ í•´ì œë¥¼ ì§€ì›í•˜ëŠ” ì»¤ìŠ¤í…€ ë¦¬ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤.  ì¼ë°˜ì ì¸ std::listë³´ë‹¤ ì„±ëŠ¥ì´ ìš°ìˆ˜í•˜ë©°, ë°˜ë³µì(iterator)ë¥¼ ì§ì ‘ êµ¬í˜„í•˜ì—¬ STL ìŠ¤íƒ€ì¼ì˜ ìˆœíšŒê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

## ğŸ§  ì„¤ê³„ íŠ¹ì§•
| í•­ëª© | ì„¤ëª… |
|------|-----| 
| ë©”ëª¨ë¦¬ ê´€ë¦¬ | CFixedAllocNoSyncë¥¼ í†µí•´ ITEM ë‹¨ìœ„ chunk ë©”ëª¨ë¦¬ í• ë‹¹ | 
| ë°ì´í„° êµ¬ì¡° | ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (prev/next í¬ì¸í„° í¬í•¨) | 
| ë°˜ë³µì | STL ìŠ¤íƒ€ì¼ì˜ ++, --, *, ==, != ì—°ì‚°ì ì§€ì› | 
| ì‚½ì… | push_back, push_front ì§€ì› | 
| ì‚­ì œ | erase(iterator)ë¡œ ë…¸ë“œ ì œê±° | 
| ì´ˆê¸°í™” | clear()ë¡œ ì „ì²´ ë©”ëª¨ë¦¬ í•´ì œ ë° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™” | 



## ğŸ§± í•µì‹¬ êµ¬ì¡°
### ğŸ”¹ ITEM êµ¬ì¡°ì²´
```cpp
struct ITEM {
    Type data;
    ITEM* prev;
    ITEM* next;
    ITEM() : prev(0), next(0) {}
};
```

### ğŸ”¹ ë°˜ë³µì(iterator)
```cpp
class iterator {
    ITEM* m_pItem;
    // ++, --, *, ==, != ì—°ì‚°ì ì˜¤ë²„ë¼ì´ë”©
};
```

## ğŸ”¹ ì£¼ìš” ë©”ì„œë“œ
```cpp
void push_back(const Type& data);
void push_front(const Type& data);
iterator erase(iterator pos);
void clear();
iterator begin();
iterator end();
```


## âš¡ ì„±ëŠ¥ ì´ì 
- new/delete ëŒ€ì‹  chunk ë‹¨ìœ„ ë©”ëª¨ë¦¬ í’€ì„ ì‚¬ìš© â†’ í• ë‹¹ ì†ë„ í–¥ìƒ
- ë©”ëª¨ë¦¬ ë‹¨í¸í™” ê°ì†Œ
- ë°˜ë³µì ê¸°ë°˜ ìˆœíšŒë¡œ STL í˜¸í™˜ì„± í™•ë³´
- erase() ì‹œ ë©”ëª¨ë¦¬ ì¦‰ì‹œ ë°˜í™˜ ê°€ëŠ¥

## ğŸ§ª ì‚¬ìš© ì˜ˆì‹œ
```cpp
TFastList<TEdge> listEdge;
for (auto itr = listEdge.begin(); itr != listEdge.end(); ++itr) {
    arFeatureLine[i++] = (*itr);
}
```

## ì „ì²´ ì†ŒìŠ¤
```cpp
#pragma once
#include "fixalloc.h"
template <class Type>
class TFastList
{
public:
    struct ITEM {       
        Type        data;
        ITEM*       prev;
        ITEM*       next;
        ITEM() : prev(0), next(0) {}
    };
    TFastList(): m_pHead(0), m_pTail(0), m_nSize(0) 
    {
        m_pAx = new CFixedAllocNoSync(sizeof(ITEM));
    }
    ~TFastList() 
    { 
        clear(); 
        if( m_pAx )
        {
            delete m_pAx;
        }
    }
    class iterator
    {
    public:
        friend class TFastList;
        iterator() : m_pItem(0) {}
        iterator(ITEM* pItem) : m_pItem(pItem) {}
        //ì˜¤í¼ë ˆì´í„° ì¬ì •ì˜
        //iterator í•˜ë‚˜ ì¦ê°€
        iterator& operator++()
        {
            m_pItem = m_pItem->next;
            return *this;
        }
        iterator operator++(int)
        {
            iterator Temp = *this;
            m_pItem = m_pItem->next;
            return Temp;
        }
        //iterator í•˜ë‚˜ ê°ì†Œ
        iterator& operator--()
        {
            m_pItem = m_pItem->prev;
            return *this;
        }
        iterator operator--(int)
        {
            iterator Temp = *this;
            m_pItem = m_pItem->prev;
            return Temp;
        }
        //í•´ë‹¹ iteratorì˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        Type& operator*()
        {
            return m_pItem->data;
        }
        //iterator ê°™ì€ì§€ ë¹„êµ ì—°ì‚°ì ì¬ì •ì˜
        bool operator==(const iterator& itr)
        {
            if (itr.m_pItem == m_pItem) return true;
            return false;
        }
        //iterator ë‹¤ë¥¸ì§€ ë¹„êµ ì—°ì‚°ì ì¬ì •ì˜
        bool operator!=(const iterator& itr)
        {
            if (itr.m_pItem != m_pItem) return true;
            return false;
        }
    protected:
        ITEM* m_pItem;
    };
public:
    friend class iterator;
    //iterator ê´€ë ¨ ê¸°ë³¸ í•¨ìˆ˜ë“¤
    iterator begin() { return iterator(m_pHead); }
    iterator end() { return iterator(0); }
    unsigned int size() { return m_nSize; }
    bool empty() { return (m_nSize==0); }
    
    void push_back(const Type& data)
    {
        m_nSize++;
        ITEM* pItem = (ITEM*)m_pAx->Alloc();
        ASSERT( pItem );
        pItem->data = data;
        pItem->prev = m_pTail;
        pItem->next = 0;
        if (m_pTail) 
        { 
            m_pTail->next = pItem; 
            m_pTail = pItem; 
        }
        else m_pHead = m_pTail = pItem;
    }

    void push_front(const Type& data)
    {
        m_nSize++;
        ITEM* pItem = (ITEM*)m_pAx->Alloc();
        ASSERT( pItem );
        pItem->data = data;
        pItem->prev = 0;
        pItem->next = m_pHead;
        if (m_pHead) 
        { 
            m_pHead->prev = pItem; 
            m_pHead = pItem; 
        }
        else m_pHead = m_pTail = pItem;
    }

    void clear()
    {
        m_pAx->FreeAll();
        m_pHead = 0;
        m_pTail = 0;
        m_nSize = 0;
    }

    iterator erase(iterator pos)
    {
        m_nSize--;
        ITEM* pPrev = pos.m_pItem->prev;
        ITEM* pNext = pos.m_pItem->next;
        if (pPrev == 0) m_pHead = pNext;
        else pPrev->next = pNext;
        if (pNext == 0) m_pTail = pPrev;
        else pNext->prev = pPrev;
        m_pAx->Free(pos.m_pItem);       
        return iterator(pNext);
    }
protected:
    ITEM* m_pHead;
    ITEM* m_pTail;
    CFixedAllocNoSync* m_pAx;
    unsigned int m_nSize;
};

TFastList<TEdge>    listEdge;
TFastList<TEdge>::iterator itr;
for (itr = listEdge.begin(); itr != listEdge.end(); ++itr)
{
    arFeatureLine[i++] = (*itr);
}

```



## ğŸ“Œ í™•ì¥ ì•„ì´ë””ì–´
- reverse_iterator ì¶”ê°€
- insert(iterator, Type) ì§€ì›
- find, sort, merge ë“± STL ìœ ì‚¬ ê¸°ëŠ¥ í™•ì¥
