# ⚡ 함수 호출 오버헤드와 Inline 함수

작은 크기의 함수를 호출할 때는 함수 실행 자체보다 **호출 과정에서
발생하는 부가적 오버헤드**가 상대적으로 더 크게 작용할 수 있습니다.\
예를 들어, 함수 호출 시 다음과 같은 과정이 필요합니다.

------------------------------------------------------------------------

## 📌 함수 호출 과정에서 발생하는 오버헤드

1.  **돌아올 리턴 주소 저장**\
2.  **CPU 레지스터 값 저장**\
3.  **함수 매개변수를 스택에 저장**\
4.  **함수 실행**\
5.  **함수의 리턴 값을 임시 변수에 저장**\
6.  **저장된 레지스터와 CPU 상태 복구**\
7.  **리턴 주소로 복귀**

![함수 호출
오버헤드](/image/call_function.jpg)

이처럼 함수 호출에는 실행 외에도 상당한 준비 및 정리 과정이 필요합니다.

------------------------------------------------------------------------

## 🚀 Inline 함수란?

함수 이름 앞에 `inline` 키워드를 붙이면 **컴파일러가 함수 호출 코드를
생성하지 않고**,\
호출 위치에 함수 코드를 그대로 삽입하도록 요청할 수 있습니다.

즉, **함수 호출 오버헤드를 줄이는 방법**입니다.\
다만, 이는 **컴파일러에게 주는 요청**이지 반드시 반영되는 것은 아닙니다.

------------------------------------------------------------------------

## 📝 Inline 함수 적용 조건과 제약

-   컴파일러가 `inline` 요구를 수용할지 여부를 판단
-   **허용되지 않는 경우**:
    -   재귀 함수 (`recursion`)
    -   지나치게 긴 함수
    -   `static` 지역 변수를 가지는 함수
    -   `goto` 문 포함 함수
-   **자동으로 inline 처리되는 경우**:
    -   클래스 선언부에서 정의된 멤버 함수
    -   생성자를 포함한 짧은 멤버 함수

------------------------------------------------------------------------

## ⚖️ Inline 함수의 장단점

### ✅ 장점

-   함수 호출 오버헤드 제거 → 성능 향상
-   코드 가독성을 유지하면서 성능 개선
-   매크로 대체보다 안전하고 타입 검사 가능

### ❌ 단점

-   코드 크기 증가 (Code bloat) → 캐시 효율 저하
-   너무 큰 함수를 inline하면 성능 저하 가능
-   디버깅 시 함수 호출 스택 추적이 어려워질 수 있음

------------------------------------------------------------------------

## 🔍 Inline 함수의 사용 가이드

-   **작고 자주 호출되는 함수**에 적합\
    (예: getter, setter, 단순 수학 연산 함수)
-   **재귀 함수, 복잡한 로직**에는 부적합
-   컴파일러 최적화에 의해 자동 inline이 적용될 수도 있음

------------------------------------------------------------------------

## 📌 정리

-   함수 호출은 리턴 주소 저장, 레지스터 백업, 스택 사용 등으로 인해
    오버헤드가 발생
-   `inline`은 호출 오버헤드를 줄이기 위해 **함수 코드를 직접 삽입**하는
    방식
-   작은 함수, 멤버 함수 등은 자동 inline 가능
-   남용 시 코드 크기 증가로 성능 저하 가능

👉 결론: **짧고 자주 호출되는 함수**에 `inline`을 사용하는 것이
이상적이다.
