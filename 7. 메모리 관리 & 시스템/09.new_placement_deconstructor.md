#🧨 C++에서 소멸자 직접 호출하기 (~Destructor())
C++에서는 객체가 스코프를 벗어나거나 delete를 통해 메모리가 해제될 때 **소멸자(Destructor)**가 자동으로 호출됩니다.  하지만 개발자가 직접 소멸자를 호출하는 것도 가능합니다.

## 🔍 예제 코드
```cpp
#include <iostream>

class A {
public:
    A() {
        std::cout << "Constructor called" << std::endl;
    }
    ~A() {
        std::cout << "Destructor called" << std::endl;
    }
};

int main() {
    A a;
    a.~A();  // 소멸자 직접 호출

    // 객체 a는 여전히 스코프 내에 있으므로
    // main 함수 종료 시 자동으로 소멸자가 다시 호출됨

    return 0;
}
```

## 🧾 출력 결과
```
Constructor called
Destructor called
Destructor called
```


## ⚠️ 왜 두 번 호출되는가?
- a.~A(); → 개발자가 직접 소멸자 호출
- main() 종료 시 → a가 스코프를 벗어나며 자동으로 소멸자 호출
즉, 동일한 객체에 대해 소멸자가 두 번 호출되므로 **정의되지 않은 동작(undefined behavior)**이 발생할 수 있습니다. 메모리 해제, 리소스 반환 등이 중복되면 프로그램이 비정상적으로 동작할 수 있습니다.

## 🧠 언제 사용할까?
소멸자를 직접 호출하는 경우는 매우 드물지만, 다음과 같은 특수한 상황에서 사용될 수 있습니다:
- **배치(new placement)**를 사용할 때
- 메모리 풀 관리에서 객체를 재사용하거나 명시적으로 파괴할 때
- 수명 제어가 필요한 커스텀 컨테이너에서
```cpp
void* mem = operator new(sizeof(A));
A* obj = new(mem) A();  // placement new
obj->~A();              // 명시적 소멸자 호출
operator delete(mem);   // 메모리 해제
```


## 🚫 주의사항
| 항목 | 설명 |
|-----|------| 
| 자동 소멸자 호출 | 스코프 종료 시 자동 호출됨 | 
| 직접 호출 시 중복 위험 | 동일 객체에 대해 두 번 호출될 수 있음 | 
| 안전하게 사용하려면 | 메모리 직접 관리 상황에서만 사용 | 
| 일반적인 코드에서는 사용 ❌ | 불필요한 직접 호출은 피해야 함 | 



## ✅ 요약
- C++에서는 소멸자를 직접 호출할 수 있지만, 매우 조심해서 사용해야 합니다.
- 일반적인 객체는 스코프 종료 시 자동으로 소멸되므로, 직접 호출은 중복 파괴를 유발할 수 있습니다.
- placement new와 같은 고급 메모리 관리 기법을 사용할 때만 명시적 소멸자 호출이 필요합니다.

----

#🧠 Placement New란?
## 🔹 일반적인 new vs Placement new
| 구분 | 설명 |
|------|-----| 
| 일반 new | 메모리 할당 + 생성자 호출 | 
| Placement new | 이미 할당된 메모리에 생성자만 호출 | 

```cpp
Type* obj = new Type();           // 일반 new
void* mem = operator new(sizeof(Type)); // 메모리만 할당
Type* obj = new(mem) Type();      // placement new
```


## 🔧 사용 예제
```cpp
#include <iostream>
#include <new> // placement new

class A {
public:
    A() { std::cout << "Constructor called\n"; }
    ~A() { std::cout << "Destructor called\n"; }
};

int main() {
    // 1. 메모리만 먼저 확보
    void* buffer = operator new(sizeof(A));

    // 2. 확보된 메모리에 객체 생성
    A* obj = new(buffer) A;

    // 3. 명시적으로 소멸자 호출
    obj->~A();

    // 4. 메모리 해제
    operator delete(buffer);

    return 0;
}
```


## 📌 동작 흐름
- operator new(size)로 원시 메모리만 확보
- new(ptr) Type(...)로 해당 위치에 객체 생성
- 객체가 자동으로 소멸되지 않기 때문에 소멸자 직접 호출 필요
- operator delete(ptr)로 메모리 수동 해제

## 🎯 언제 사용하나?
- 메모리 풀(Pool Allocator): 여러 객체를 하나의 큰 메모리 블록에 생성
- 커스텀 컨테이너: std::vector처럼 내부에서 메모리를 직접 관리할 때
- 성능 최적화: 메모리 할당/해제를 줄여 성능 향상
- 특수한 수명 제어: 객체를 특정 시점에 생성/소멸하고 싶을 때

## ⚠️ 주의사항
| 항목 | 설명 |
|------|-----| 
| 자동 소멸 ❌ | placement new로 생성된 객체는 자동으로 소멸되지 않음 | 
| 소멸자 직접 호출 필요 | obj->~Type(); 반드시 호출해야 함 | 
| 메모리 해제도 직접 | operator delete(ptr);로 수동 해제 | 
| 예외 처리 주의 | 생성자에서 예외 발생 시 메모리 누수 가능성 있음 | 



## 🧩 요약
- Placement new는 메모리와 객체 생성을 분리할 수 있게 해주는 강력한 도구입니다.
- 일반적인 상황에서는 잘 쓰이지 않지만, 고급 시스템 프로그래밍이나 라이브러리 개발에서는 필수적인 기술입니다.
- 사용 시에는 소멸자 호출과 메모리 해제를 반드시 수동으로 처리해야 합니다.

----
