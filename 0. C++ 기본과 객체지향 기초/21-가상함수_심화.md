# C++ 가상 함수 심화 정리

## 📌 1. 상향 형 변환 vs 하향 형 변환
| 변환 종류 | 설명 | 바인딩 방식 | 안전성 | 
| Upcasting | 자식 → 부모 | 정적 바인딩 | 안전함 | 
| Downcasting | 부모 → 자식 | 동적 바인딩 (보통 dynamic_cast 사용) | 위험함 (RTTI 필요) | 


## 🧨 2. 함수 중복 문제 (가상 함수 없이)
```cpp
class Animal {
public:
    void speak() { cout << "Animal Speak" << endl; }
};

class Dog : public Animal {
public:
    void speak() { cout << "Dog Speak" << endl; }
};


shared_ptr<Animal> animal = make_shared<Dog>();
animal->speak(); // Animal Speak → 정적 바인딩
```

- 문제점: Animal의 speak()가 호출됨. Dog의 speak()는 무시됨.
- 원인: virtual 키워드가 없기 때문에 정적 바인딩 발생

## 🧬 3. 가상 함수란?
- virtual 키워드로 선언된 멤버 함수
- 동적 바인딩을 통해 실행 시간에 실제 객체 타입에 따라 함수 호출 결정
- **다형성(polymorphism)**의 핵심
```cpp
class Base {
public:
    virtual void f(); // 가상 함수
};
```


## 🔁 4. 오버라이딩 vs 재정의 vs 오버로딩
| 구분 | 오버로딩 | 재정의 | 오버라이딩 |
|------|----------|-------|-------------|
| 정의 | 이름 같고 매개변수 다름 | 이름, 매개변수, 리턴 모두 같음 | 재정의 + virtual 기반 | 
| 바인딩 | 정적 바인딩 | 정적 바인딩 | 동적 바인딩 | 
| 목적 | 함수 이름 재사용 | 파생 클래스에서 기능 변경 | 다형성 구현 | 
| 예시 | void f(int) vs void f(double) | void f() in Base and Derived | virtual void f() → void f() override | 



## 🧪 5. 오버라이딩 실전 예제
```cpp
class Base {
public:
    virtual void print() { cout << "Base::print" << endl; }
};

class Derived : public Base {
public:
    void print() override { cout << "Derived::print" << endl; }
};

int main() {
    Base* p = new Derived();
    p->print(); // Derived::print → 동적 바인딩
    delete p;
}
```

- virtual 없으면 Base::print() 호출됨
- virtual 있으면 Derived::print() 호출됨

## 🧭 6. 범위 지정 연산자 ::로 정적 바인딩
```cpp
class Shape {
public:
    virtual void draw() { cout << "Shape draw" << endl; }
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Circle draw" << endl;
        Shape::draw(); // 명시적 정적 바인딩
    }
};


Shape* p = new Circle();
p->draw(); // Circle draw → Shape draw
p->Shape::draw(); // Shape draw
```

- Shape::draw() 명시적으로 호출하면 정적 바인딩 강제

## 🧠 7. 가상 함수의 특징 요약
- virtual 키워드로 선언
- 동적 바인딩을 통해 실행 시간에 실제 객체 타입에 따라 함수 호출
- 상속 관계에서 다형성 구현
- RTTI 기반으로 동작
- override 키워드 사용 권장 (컴파일러가 오버라이딩 여부 체크)

## 🧨 8. 가상 함수 없이 재정의된 경우
```cpp
class Base {
public:
    void f() { cout << "Base::f()" << endl; }
};

class Derived : public Base {
public:
    void f() { cout << "Derived::f()" << endl; }
};


Base* pBase = new Derived();
pBase->f(); // Base::f() → 정적 바인딩
```

- virtual 없으면 기본 클래스의 함수가 호출됨
- 다형성 무효화

## ✅ 마무리 요약
| 키워드 | 의미 | 바인딩 방식 | 다형성 | 
| virtual | 가상 함수 선언 | 동적 바인딩 | O | 
| override | 오버라이딩 명시 | 컴파일러 체크 | O | 
| :: | 범위 지정 | 정적 바인딩 | X | 

---




