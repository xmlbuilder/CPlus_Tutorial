# C++ Move 생성자 완전 정복

## 📌 1. Move 생성자란?
### ✅ 정의
- **임시 객체(rvalue)**의 자원을 **복사하지 않고 "이동"**하는 생성자
- 기존의 복사 생성자보다 훨씬 빠름 (복사 대신 포인터만 이동)
### ✅ 기본 형태
```cpp
class Power {
private:
    int* kick;

public:
    // Move 생성자
    Power(Power&& other) noexcept {
        kick = other.kick;      // 자원 이동
        other.kick = nullptr;   // 원본은 무효화
    }
};
```

### ✅ 사용 예
```cpp
Power a(100);
Power b = std::move(a); // a의 자원을 b로 이동
```


## ⚠️ 2. Move 생성자의 부작용
### ❗ 자원 무효화
- 이동된 객체(a)는 더 이상 유효한 자원을 가지지 않음
- 이후 a를 사용하면 예상치 못한 동작 발생 가능
### ❗ 복사와 혼동
- std::move()는 단순히 캐스팅일 뿐, 실제 이동은 move 생성자가 수행
- move 생성자가 없으면 복사 생성자가 호출됨 → 성능 저하
### ❗ 깊은 복사 미구현 시 문제
- 포인터 멤버가 있을 경우, **얕은 이동(shallow move)**은 위험
- 자원 해제 시 이중 delete 또는 메모리 누수 발생 가능

## 🧠 3. 자동 생성 여부와 = delete 필요성
### ✅ 자동 생성 조건
- 클래스에 사용자 정의 복사 생성자/대입 연산자가 없고
- 포인터나 참조 멤버가 있어도 특별한 제약이 없으면
- 컴파일러가 기본 move 생성자를 자동 생성
```cpp
class Power {
    int kick;
    // 컴파일러가 자동으로 move 생성자 생성
};
```


## ❌ 언제 = delete 해야 할까?
### ① 자원 공유가 중요한 경우
```cpp
class SharedResource {
public:
    SharedResource(SharedResource&&) = delete;
};
```

- 자원을 공유하거나 복제 불가능한 경우
- 이동하면 의미가 없는 객체가 될 수 있음
### ② 객체의 상태가 반드시 유지되어야 할 경우
- 예: 싱글톤 객체, 파일 핸들, 스레드 핸들
- 이동 후 원본이 무효화되면 시스템 자원 누수 발생 가능
### ③ 복사/이동이 모두 금지되어야 할 경우
```cpp
class NonCopyable {
public:
    NonCopyable(const NonCopyable&) = delete;
    NonCopyable(NonCopyable&&) = delete;
};
```

- 객체가 절대 복사/이동되면 안 되는 경우
- 예: 로그 객체, 디버깅 핸들, 고정된 메모리 영역

## 🧩 요약 테이블
| 항목 | 설명 |
|------|------------------------------------------| 
| Move 생성자 목적 | 자원 복사 없이 이동하여 성능 최적화 | 
| 형태 | ClassName(ClassName&& other) | 
| 부작용 | 원본 객체 무효화, 얕은 이동 시 메모리 문제 | 
| 자동 생성 조건 | 사용자 정의 복사 생성자 없을 때 | 
| = delete 필요 시점 | 자원 공유, 상태 유지, 복사 금지 객체 | 



## 🎯 실전 팁
- 항상 std::move()를 사용할 때는 move 생성자가 정의되어 있는지 확인
- 포인터 멤버가 있다면 **깊은 이동(deep move)**을 구현해야 안전
- = delete는 의도 명확화와 버그 방지에 매우 효과적

----
