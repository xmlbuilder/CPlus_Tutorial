 # 🧠 Linux에서 Shared Memory 구현하기 (Windows SharedMemory 스타일)
이 문서는 Linux 환경에서 Windows의 SharedMemory와 유사한 방식으로 프로세스 간 메모리 공유를 구현하는 방법을 설명합니다.\ POSIX 공유 메모리 API를 활용하며, shm_open, ftruncate, mmap, munmap, shm_unlink 등을 사용합니다.

## 📦 주요 API 개요
|------|-----|
| 함수 | 설명 | 
| shm_open | 공유 메모리 객체 생성 또는 열기 | 
| ftruncate | 공유 메모리 크기 설정 | 
| mmap | 공유 메모리를 프로세스 주소 공간에 매핑 | 
| munmap | 매핑 해제 | 
| shm_unlink | 공유 메모리 객체 제거 | 



## 🧾 소스 코드 설명
```cpp
#include <iostream>
#include <fcntl.h>      // O_CREAT, O_RDWR
#include <sys/mman.h>   // shm_open, mmap, PROT_*, MAP_*
#include <unistd.h>     // ftruncate, close
#include <cstring>      // memcpy
#include <sys/stat.h>   // mode constants

const char* SHM_NAME = "/my_shared_memory";
const size_t SHM_SIZE = 4096;

int main() {
    // 1. 공유 메모리 객체 생성 또는 열기
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        std::cerr << "Failed to open shared memory" << std::endl;
        return 1;
    }

    // 2. 공유 메모리 크기 설정
    if (ftruncate(shm_fd, SHM_SIZE) == -1) {
        std::cerr << "Failed to set size" << std::endl;
        return 1;
    }

    // 3. 메모리 매핑
    void* ptr = mmap(0, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (ptr == MAP_FAILED) {
        std::cerr << "Failed to map memory" << std::endl;
        return 1;
    }

    // 4. 데이터 쓰기
    const char* message = "Hello from shared memory!";
    memcpy(ptr, message, strlen(message) + 1);

    std::cout << "Message written to shared memory: " << static_cast<char*>(ptr) << std::endl;

    // 5. 메모리 매핑 해제
    munmap(ptr, SHM_SIZE);

    // 6. 파일 디스크립터 닫기
    close(shm_fd);

    // 7. 공유 메모리 객체 제거 (선택적)
    // shm_unlink(SHM_NAME);

    return 0;
}
```
## 실전 예제
```cpp
// First 프로세스 - 공유 메모리 Create 및 Write
////////////////////////////////////
//     First Process Shared Memory    
////////////////////////////////////
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>
#include <unistd.h>
 
#define  KEY_NUM   1234
#define  MEM_SIZE  4096
 
using namespace std;
 
int shmid;
static int SharedMemoryCreate();
static int SharedMemoryWrite(char *shareddata, int size);
static int SharedMemoryRead(char *sMemory);
static int SharedMemoryFree(void);
 
int main(int argc, char *argv[])
{
    char buffer[MEM_SIZE] = {1,};
    
    SharedMemoryCreate();
    sleep(5);
    
    SharedMemoryWrite(buffer, sizeof(buffer));
    return 0;
}
 
static int SharedMemoryCreate()
{
    if((shmid = shmget((key_t)KEY_NUM, MEM_SIZE, IPC_CREAT| IPC_EXCL | 0666)) == -1) {
        printf("There was shared memory.");
        
        shmid = shmget((key_t)KEY_NUM, MEM_SIZE, IPC_CREAT| 0666);
        
        if(shmid == -1)
        {
            perror("Shared memory create fail");
            return 1;
        }
        else
        {
            SharedMemoryFree();
            shmid = shmget((key_t)KEY_NUM, MEM_SIZE, IPC_CREAT| 0666);
            
            if(shmid == -1)
            {
                perror("Shared memory create fail");
                return 1;
            }
        }
    }
    
    return 0;
}
 
static int SharedMemoryWrite(char *shareddata, int size)
{
    void *shmaddr;
    if(size > MEM_SIZE)
    {
        printf("Shared memory size over");
        return 1;
    }
    
    if((shmaddr = shmat(shmid, (void *)0, 0)) == (void *)-1) 
    {
        perror("Shmat failed");
        return 1;
    }
    
    memcpy((char *)shmaddr, shareddata, size);
    
    if(shmdt(shmaddr) == -1) 
    {
        perror("Shmdt failed");
        return 1;
    }
    return 0;
}
 
static int SharedMemoryRead(char *sMemory)
{
    void *shmaddr;
    char mess[MEM_SIZE] = {0};
    
    if((shmaddr = shmat(shmid, (void *)0, 0)) == (void *)-1)
    {
        perror("Shmat failed");
        return 1;
    }
    
    memcpy(sMemory, (char *)shmaddr, sizeof(mess));
    
    if(shmdt(shmaddr) == -1)
    {
        perror("Shmdt failed");
        return 1;
    }
    return 0;
}
 
static int SharedMemoryFree(void)
{
    if(shmctl(shmid, IPC_RMID, 0) == -1) 
    {
        perror("Shmctl failed");
        return 1;
    }
    
    printf("Shared memory end");
    return 0;
}
 


// Second 프로세스 - 공유 메모리 Connect 및 Read
///////////////////////////////////////
//    Second Process Shared Memory    
////////////////////////////////////////
#include <iostream>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

#define  KEY_NUM   1234
#define  MEM_SIZE  4096
using namespace std;
int shmid;
static int SharedMemoryInit();
static int SharedMemoryWrite(char *sMemory, int size);
static int SharedMemoryRead(char *sMemory);
int main(int argc, char *argv[])
{
    char buffer[MEM_SIZE] = {0,};
    SharedMemoryInit();
    
    while(1)
    {
        SharedMemoryRead(buffer);
        if(buffer[0] == 1)
        {
            cout << "Receive data from shared memory!" << endl;
            break;
        }    
    }
    return 0;
}

static int SharedMemoryInit()
{
    void *shmaddr;
    
    if((shmid = shmget((key_t)KEY_NUM, 0, 0)) == -1)
    {
        perror("Shmid failed");
    }
    
    return 0;
}

static int SharedMemoryWrite(char *sMemory, int size)
{
    void *shmaddr;
    
    if((shmaddr = shmat(shmid, (void *)0, 0)) == (void *)-1)
    {
        perror("Shmat failed");
    }
    
    memcpy((char *)shmaddr, sMemory, size);
    
    if(shmdt(shmaddr) == -1)
    {
        perror("Shmdt failed");
        exit(1);
    }
    return 0;
}

static int SharedMemoryRead(char *sMemory)
{
    void *shmaddr;
    
    if((shmaddr = shmat(shmid, (void *)0, 0)) == (void *)-1)
    {
        perror("Shmat failed");
    }
    
    memcpy(sMemory, (char *)shmaddr, sizeof(sMemory));
    
    if(shmdt(shmaddr) == -1)
    {
        perror("Shmdt failed");
    }
    
    return 0;
}
```

## 🧪 실행 방법
g++ -o shared_memory shared_memory.cpp
./shared_memory


- 다른 프로세스에서도 shm_open으로 동일한 이름을 열면 같은 메모리 공간에 접근 가능
- shm_unlink는 공유 메모리 객체를 시스템에서 제거하므로, 모든 프로세스가 종료된 후 호출해야 안전

## ✅ 장점과 주의사항
| 항목 | 설명 | 
|------|-----|
| ✅ 장점 | 프로세스 간 빠른 데이터 공유 가능 | 
| ✅ 장점 | 커널이 관리하므로 안정적 | 
| ⚠️ 주의 | 이름 충돌 방지 필요 (/my_shared_memory는 고유하게 설정) | 
| ⚠️ 주의 | shm_unlink를 적절한 시점에 호출해야 메모리 누수 방지 | 
| ⚠️ 주의 | 동기화가 필요할 경우 pthread_mutex + mmap 조합 고려 | 



## 🔄 Windows와 비교
| 항목 | Windows | Linux | 
|------|--------|--------|
| API | CreateFileMapping, MapViewOfFile | shm_open, mmap | 
| 이름 | 전역 이름 사용 가능 | /로 시작하는 고유 이름 필요 | 
| 동기화 | Mutex, Event, Semaphore | pthread_mutex, sem_open 등 | 

----



