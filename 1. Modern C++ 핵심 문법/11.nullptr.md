# 🚀 Modern C++의 nullptr 키워드
C++11부터 도입된 nullptr은 기존의 NULL 매크로를 대체하는 타입 안전한 null 포인터 표현입니다.  이 키워드는 코드의 모호함을 줄이고, 함수 오버로딩 상황에서 의도한 함수가 정확히 호출되도록 도와줍니다.

## 🔍 문제점: NULL의 모호성
기존 C++에서는 NULL이 단순히 0으로 정의된 매크로였기 때문에, 다음과 같은 함수 오버로딩 상황에서 문제가 발생할 수 있습니다:
```cpp
void funct(const char*);  // 포인터를 받는 함수
void funct(int);          // 정수를 받는 함수

funct(NULL);              // funct(int) 호출됨 (의도와 다름)
```
위 코드에서 funct(NULL)은 NULL이 0으로 간주되어 funct(int)가 호출됩니다. 이는 null 포인터를 전달하려는 의도와 다르게 동작합니다.

## ✅ 해결책: nullptr 사용
C++11 이후에는 nullptr을 사용하여 명확하게 null 포인터를 전달할 수 있습니다:
```cpp
funct(nullptr);           // funct(const char*) 호출됨 (의도대로 동작)
```

nullptr은 std::nullptr_t 타입을 가지며, 포인터 타입과만 호환되므로 함수 오버로딩 시 정확한 함수가 선택됩니다.

## 🎯 요약
| 표현 | 의미 | 함수 선택 결과 |
|------|-----|---------------| 
| NULL | 정수 0 | funct(int) 호출됨 | 
| nullptr | null 포인터 | funct(const char*) 호출됨 | 


nullptr을 사용하면 코드의 명확성, 안정성, 예측 가능성이 향상됩니다.  모던 C++을 사용할 때는 반드시 NULL 대신 nullptr을 사용하는 습관을 들이는 것이 좋습니다.



## 🧵 C 언어에서의 nullptr 개념
C++11에서 도입된 nullptr은 C 언어에는 직접적으로 도입되지 않았지만, C23 표준에서 이에 대응하는 개념이 부분적으로 반영되었습니다.
### 📌 기존 C의 null 포인터 표현
C에서는 null 포인터를 다음과 같이 표현해왔습니다:
```cpp
#define NULL ((void*)0)
```

- NULL은 일반적으로 <stddef.h> 또는 <stdio.h>에 정의되어 있으며, (void*)0으로 표현됩니다.
- 하지만 여전히 매크로이기 때문에 타입 안전성이 부족하고, 함수 오버로딩이 없는 C에서는 큰 문제가 되지 않지만, 컴파일러가 타입을 명확히 구분하지 못하는 경우가 생길 수 있습니다.

### 🆕 C23의 변화: nullptr은 아니지만...
C23 표준에서는 nullptr이라는 키워드 자체는 도입되지 않았지만, 다음과 같은 개선이 이루어졌습니다:
- nullptr과 유사한 타입 안전한 null 표현을 위한 개선된 매크로가 논의됨
- nullptr_t와 같은 타입은 C++에만 존재하며, C에서는 여전히 NULL을 사용하지만, 컴파일러가 더 엄격하게 타입을 검사하도록 개선됨
- 일부 컴파일러(GCC, Clang 등)는 __nullptr 또는 nullptr을 내부적으로 지원하기도 함 (비표준)
### 🔍 비교: C vs C++
| 언어 | null 포인터 표현 | 타입 안전성 | 함수 오버로딩 대응 |
|------|----------------|-----------|------------------| 
| C | NULL ((void*)0) | 낮음 | 없음 | 
| C++ | nullptr (nullptr_t) | 높음 | 정확한 함수 선택 가능 | 


### ✅ 요약
- C에서는 nullptr 키워드가 직접 도입되지는 않았지만, C23을 통해 null 포인터 표현의 명확성과 안전성이 점차 개선되고 있습니다.
- 타입 안전성과 함수 선택의 명확성을 원한다면, C++에서 nullptr을 사용하는 것이 훨씬 유리합니다.
- C 코드에서도 NULL 대신 (void*)0을 명시적으로 사용하는 것이 더 안전할 수 있습니다.
