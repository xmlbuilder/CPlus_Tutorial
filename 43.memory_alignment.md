# 📘 C++에서의 메모리 Alignment 정리 문서
## 🧠 개념 정의
메모리 Alignment란, 변수나 구조체의 멤버가 특정 바이트 경계에 맞춰서 배치되는 것을 의미합니다. 이는 CPU가 메모리를 더 빠르고 효율적으로 접근할 수 있도록 도와줍니다.
### 📌 왜 필요한가?
- ✅ 메모리 접근 최적화: CPU는 특정 바이트 경계에 정렬된 데이터를 더 빠르게 읽고 씁니다.
- ✅ 하드웨어 제약 만족: 일부 CPU는 정렬되지 않은 데이터 접근 시 예외를 발생시킵니다.
- ✅ 데이터 공유 및 재사용: 같은 주소에 다른 타입의 데이터를 안전하게 저장하려면 정렬이 필요합니다.

## 🧱 기본 용어
| 용어 | 설명 | 
|------|------|
| Alignment | 데이터가 메모리에서 배치되는 바이트 경계 | 
| Padding | 정렬을 맞추기 위해 삽입되는 빈 공간 | 
| alignof(T) | 타입 T의 정렬 요구 바이트 수 반환 | 
| alignas(N) | 변수 또는 구조체를 N 바이트 경계에 맞춰 정렬 | 
| std::max_align_t | 플랫폼에서 가장 큰 정렬 요구를 갖는 타입 | 



## 🧪 코드 예제 분석
```cpp
struct Storage {
    char a;       // 1 byte
    int b;        // 4 bytes
    double c;     // 8 bytes
    long long d;  // 8 bytes
};
```

- char 다음에 int가 오면 3바이트 padding이 삽입됨
- 전체 구조체는 24바이트로 정렬됨
```cpp
struct alignas(std::max_align_t) AlignasStorage {
    char a;
    int b;
    double c;
    long long d;
};
```

- alignas(std::max_align_t)는 구조체 전체를 최대 정렬 단위에 맞춤
- 대부분의 플랫폼에서 max_align_t는 8 또는 16 바이트
## 🔍 출력 결과
```
std::cout << alignof(Storage);        // 8
std::cout << alignof(AlignasStorage); // 8
std::cout << sizeof(Storage);         // 24
std::cout << sizeof(AlignasStorage);  // 24
```

- 두 구조체 모두 8바이트 정렬, 크기도 동일
- 하지만 AlignasStorage는 명시적으로 정렬을 지정했기 때문에 플랫폼 간 호환성이 더 좋음

## 🛠️ 실전 사용 예시
### . SIMD 최적화
```cpp
struct alignas(16) Vector4 {
    float x, y, z, w;
};
```

- 16바이트 정렬은 SSE/AVX 명령어와 호환됨


### 2. 커스텀 메모리 풀
```cpp
alignas(64) char cache_line_buffer[64];
```

- CPU 캐시 라인에 맞춰 정렬 → 성능 향상





## 🔍 구조체 멤버 구성
```cpp
struct alignas(std::max_align_t) AlignasStorage {
    char a;       // 1 byte
    int b;        // 4 bytes
    double c;     // 8 bytes
    long long d;  // 8 bytes
};
```


### 📦 메모리 배치 분석 (64비트 기준)
| 멤버 | 크기 | 정렬 요구 | 실제 위치 | Padding |
|------|-----|---------|-----------|--------| 
| a | 1 | 1 | 0 | +3 | 
| b | 4 | 4 | 4 |  | 
| c | 8 | 8 | 8 |  | 
| d | 8 | 8 | 16 |  | 
|  |  |  |  | +0 | 


- a 다음에 int b를 정렬하려면 4바이트 경계가 필요 → 3바이트 padding
- c는 8바이트 경계 → 이미 위치가 8이므로 OK
- d는 8바이트 경계 → 위치 16이므로 OK
- 전체 크기: 0 → 23까지 사용 → 총 24바이트


### 🧪 강제로 32바이트 정렬하려면?
```cpp
struct alignas(32) ForceAlignStorage {
    char a;
    int b;
    double c;
    long long d;
};
```

- alignof(...)는 32
- sizeof(...)는 32로 늘어남 (마지막에 padding 추가됨)

### 🔍 정리하면
- std::max_align_t는 플랫폼마다 다르지만 대부분 8 또는 16바이트
- 구조체 멤버들이 이미 그 정렬 요구를 만족하면 → 구조체 크기 변화 없음
- 구조체 배열을 만들 때는 정렬 단위에 따라 요소 간 간격이 생길 수 있음
- alignas(N)을 명시적으로 지정하면 → 구조체 전체가 N 바이트 경계에 맞춰짐

### 🧪 예시 비교
| 구조체 타입 | alignof | sizeof | 설명 |
|-----------|------|-------|---------| 
| Storage | 8 | 24 | 기본 정렬 | 
| alignas(std::max_align_t) | 8 | 24 | 최대 정렬 요구지만 변화 없음 | 
| alignas(32) | 32 | 32 | 강제 정렬, padding 추가됨 | 



## 🚫 주의 사항
- 구조체 멤버 순서에 따라 padding이 달라짐 → 크기와 성능에 영향
- alignas는 C++11 이후 표준 → __declspec(align(N))은 비표준이므로 사용 지양
- 정렬을 과도하게 지정하면 메모리 낭비 발생 가능



## ✅ 요약

| 항목 | 설명 |
|-----|------------------------} 
| alignof(T) | 타입 T의 정렬 요구 반환 | 
| alignas(N) | 변수/구조체를 N 바이트 경계에 정렬 | 
| std::max_align_t | 플랫폼 최대 정렬 단위 | 
| 목적 | 성능 최적화, 하드웨어 호환, 안전한 접근 | 



