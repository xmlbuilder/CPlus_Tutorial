# 🧩 C/C의 가변 인자 함수와 C11의 가변 인자 템플릿
C와 C에서는 인자의 개수가 고정되지 않은 함수를 만들 수 있습니다.  이를 **가변 인자 함수(variadic function)**라고 하며, 대표적인 예로 printf()가 있습니다.  C11부터는 템플릿에도 가변 인자 기능이 도입되어 훨씬 더 안전하고 유연한 방식으로 사용할 수 있게 되었습니다.

## 🔹 C 스타일 가변 인자 함수
```cpp
#include <cstdarg>
#include <cstdio>

void simplePrintf(const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
}
```

- ... : 생략 부호로 가변 인자를 표현
- va_list, va_start, va_arg, va_end : 가변 인자 처리용 매크로
- 타입 안전성이 없고, 인자 개수나 타입을 잘못 전달하면 런타임 오류 발생 가능

## 🔸 C++11 가변 인자 템플릿
template <typename... Args>
void func(Args... args);


- typename... Args : 파라미터 팩(Parameter Pack)
- args... : 팩 확장(Pack Expansion)
- 컴파일 타임에 타입이 결정되므로 타입 안전성 보장

## 🧪 예제: 재귀적으로 출력하는 print 함수
```cpp
#include <iostream>
using namespace std;

void print() {
    cout << "first print" << endl;
}

template <typename T>
void print(const T& t) {
    cout << "second print : " << t << endl;
}

template <typename First, typename... Rest>
void print(const First& first, const Rest&... rest) {
    cout << first << ", ";
    print(rest...); // 팩 확장을 통한 재귀 호출
}
```

## 📌 실행 흐름 예시
```cpp
print("first", 2, "third", 3.14159);
```

- "first" → first, 나머지 → rest
- "first" 출력 후 print(2, "third", 3.14159) 호출
- 2 → first, 나머지 → rest
- 2 출력 후 print("third", 3.14159) 호출
- "third" 출력 후 print(3.14159) 호출
- 3.14159는 단일 인자 → second print : 3.14159 출력
- 재귀 종료

## 📊 개념 비교표
| 개념 | C 스타일 가변 인자 | C++11 가변 인자 템플릿 |
|------|------------------|---------------------| 
| 문법 | ... | typename... Args | 
| 타입 안전성 | 없음 | 있음 | 
| 처리 방식 | 런타임 | 컴파일 타임 | 
| 대표 함수 | printf() | print(...), std::make_tuple(...) 등 | 
| 팩 확장 지원 | ❌ | ✅ | 
| 재귀적 처리 | 수동 | 자동 (팩 확장으로 가능) | 



## 🎯 요약
- C 스타일은 낡았지만 여전히 사용됨, 특히 C 라이브러리와의 호환성에서
- C++11 이후의 가변 인자 템플릿은 타입 안전하고 유연하며 강력
- 핵심 개념은 파라미터 팩과 팩 확장
- 재귀 호출을 통해 인자들을 하나씩 처리하는 방식이 일반적
