# 🧩 클래스 내부에서 람다와 this 캡처
클래스 내부에서 람다를 사용할 때 this를 캡처하면, 해당 객체의 멤버 변수나 메서드에 접근할 수 있습니다.  
이를 활용하면 filter, reduce, sort 같은 고차 함수도 객체 지향과 결합해 유연하게 사용할 수 있습니다.

## ✅ 예제: 클래스 내부에서 filter, reduce, sort 사용
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

class Processor {
private:
    std::vector<int> data;
    int threshold = 5;

public:
    Processor(std::vector<int> d) : data(d) {}

    void process() {
        // filter: threshold보다 큰 값만 남기기
        std::vector<int> filtered;
        std::copy_if(data.begin(), data.end(), std::back_inserter(filtered),
            [this](int val) { return val > threshold; });

        // sort: 내림차순 정렬
        std::sort(filtered.begin(), filtered.end(),
            [](int a, int b) { return a > b; });

        // reduce: 총합 계산
        int sum = std::accumulate(filtered.begin(), filtered.end(), 0,
            [](int acc, int val) { return acc + val; });

        std::cout << "Filtered & Sorted: ";
        for (int v : filtered) std::cout << v << " ";
        std::cout << "\nSum: " << sum << std::endl;
    }
};

int main() {
    Processor p({1, 3, 6, 8, 2, 10});
    p.process();
}
```

```cpp
//sort
#include <iostream>
#include <vector>
#include <algorithm>

// 비교 함수 정의
bool compare(int a, int b) {
    return a > b;  // 내림차순 정렬을 위해 'a'가 'b'보다 클 때 true 반환
}

int main() {
    // 정렬할 벡터
    std::vector<int> numbers = {4, 1, 3, 9, 7, 5, 8};

    // std::sort 함수 사용, 비교 함수로 'compare' 전달
    std::sort(numbers.begin(), numbers.end(), compare);

    // 정렬된 벡터 출력
    std::cout << "Sorted in descending order: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }

    std::cout << std::endl;
    return 0;
}
```


## 🔍 핵심 포인트
- [this] 캡처를 통해 클래스 멤버 threshold에 접근
- STL 알고리즘 (copy_if, sort, accumulate)과 람다를 결합
- 객체지향과 함수형 스타일의 자연스러운 융합

## this 갭체 예제
```cpp
#include <iostream>

class Cat {
public:

    explicit Cat(int age) : mAge{age} {}

    void speak() const {
        std::cout <<"speaking" <<std::endl;
    }

    void test() const {
        
        auto lambda = [this](){
            std::cout << this->mAge << std::endl;
            this->speak();
        };
        
        lambda();
    }

private:
    int mAge;
};

int main(){
    Cat kitty(3);
    kitty.test();
    // 3
    // speaking
}
```

---


# 🧠 함수형 프로그래밍이란?
함수형 프로그래밍은 상태와 부작용을 최소화하고, 순수 함수와 고차 함수를 중심으로 구성하는 프로그래밍 패러다임입니다.

## 🎯 주요 특징
- 순수 함수: 동일 입력 → 동일 출력, 외부 상태 변경 없음
- 불변성: 데이터 변경 대신 복사 및 변형
- 고차 함수: 함수를 인자로 받거나 반환
- 선언적 스타일: "어떻게"보다 "무엇을"에 집중

## 🚀 C++에서 함수형 프로그래밍을 도입해야 하는 이유
| 이유 | 설명 |
|------|-----|
| 표현력 향상 | map, filter, reduce 등으로 코드가 간결하고 명확해짐 | 
| 병렬 처리에 유리 | 상태 공유가 적어 병렬화가 쉬움 | 
| 버그 감소 | 부작용 없는 순수 함수는 디버깅이 쉬움 | 
| 모듈화 | 함수 단위로 분리 가능, 테스트와 재사용 용이 | 
| 현대 C++의 방향 | C++11 이후 람다, auto, std::function, ranges 등 함수형 요소가 대거 도입됨 | 

## 🧭 마무리 요약
| 요소 | 설명 | 예제 | 
|------|-----|------|
| lambda | 익명 함수, [this] 캡처로 멤버 접근 | [this](int x){ return x > threshold; } | 
| filter | 조건에 맞는 요소만 추출 | std::copy_if | 
| sort | 정렬 | std::sort | 
| reduce | 누적 계산 | std::accumulate | 

---



