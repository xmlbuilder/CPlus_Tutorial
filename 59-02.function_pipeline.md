# 📘 C++11 함수 합성 설명 문서 (Compose)

## 🔍 개요
이 문서는 C++11의 람다 표현식과 std::function을 활용하여 함수 합성을 구현한 코드에 대해 설명합니다.
함수 합성이란, 두 함수를 연결하여 하나의 새로운 함수를 만드는 기법입니다.
예: f(g(x))

## 📦 코드 전문
```cpp
#include <iostream>
#include <functional>
using namespace std;

auto compose = [](auto f, auto g) {
    return [=](auto... args) {
        return f(g(args...));
    };
};

int main()
{
    cout << compose(::negate{}, ::multiplies{})(4, 6);
}
```


## 🧠 핵심 구성 요소 설명
### 1. compose 람다
```cpp
auto compose = [](auto f, auto g) {
    return [=](auto... args) {
        return f(g(args...));
    };
};
```

- 입력: 두 함수 f, g
- 출력: f(g(args...)) 형태의 새로운 함수
- auto... args: 가변 인자 템플릿으로 여러 인자를 받을 수 있음
- [=]: 캡처 by-value로 f, g를 내부 람다에서 사용할 수 있게 함
📌 이 람다는 고차 함수로, 함수를 인자로 받고 함수를 반환합니다.

### 2. ::negate{} 와 ::multiplies{}
이 둘은 <functional> 헤더에 정의된 **함수 객체(function object)**입니다.
| 함수 객체 | 역할 | 예시 결과 |
|----------|------|---------| 
| std::multiplies<int>() | 두 값을 곱함 | 4 * 6 = 24 | 
| std::negate<int>() | 값을 음수로 바꿈 | -24 | 


### 3. compose(::negate{}, ::multiplies{})
- compose를 통해 negate(multiplies(x, y)) 형태의 합성 함수 생성
- compose(f, g)(x, y) → f(g(x, y))
즉, compose(::negate{}, ::multiplies{})(4, 6)는 다음과 같이 동작합니다:
```cpp
std::multiplies<int>()(4, 6) → 24  
std::negate<int>()(24) → -24
```


#### ✅ 실행 결과
-24



## 📌 확장 예시
다양한 함수 객체를 조합하면 더 복잡한 로직도 간단하게 표현할 수 있습니다:
```cpp
auto square = [](int x) { return x * x; };
auto double_then_square = compose(square, [](int x) { return x * 2; });
cout << double_then_square(5); // 출력: 100
```
이 방식은 auto 람다와 거의 동일한 기능을 제공하면서, std::function보다 성능이 좋고 타입 추론도 가능합니다.

```cpp
#include <iostream>
#include <functional>

// compose 함수 정의

std::function<int(int, int)> compose(
    std::function<int(int)> f,
    std::function<int(int, int)> g)
{
    return [=](int x, int y) {
        return f(g(x, y));
    };
}

int main() {
    // g(x, y) = x + y
    std::function<int(int, int)> add = [](int a, int b) {
        return a + b;
    };

    // f(z) = z * z
    std::function<int(int)> square = [](int z) {
        return z * z;
    };

    // 합성 함수 생성
    auto composed = compose(square, add);

    // 테스트
    int result = composed(3, 4); // (3 + 4)^2 = 49
    std::cout << "Result: " << result << std::endl;

    return 0;
}
```


## 🧩 템플릿 버전 (더 일반적이고 강력함)
```cpp
template <typename F, typename G>
auto compose(F f, G g) {
    return [=](auto... args) {
        return f(g(args...));
    };
}
```

### 템플릿 버전 예제
```cpp

#include <iostream>
#include <string>

// compose 템플릿 함수
template <typename F, typename G>
auto compose(F f, G g) {
    return [=](auto... args) {
        return f(g(args...));
    };
}

int main() {
    // g(x, y) = x + y
    auto add = [](int a, int b) {
        return a + b;
    };

    // f(z) = "결과는 " + z + "입니다"
    auto to_string_with_message = [](int result) {
        return "결과는 " + std::to_string(result) + "입니다";
    };

    // 합성 함수 생성
    auto composed = compose(to_string_with_message, add);

    // 테스트
    std::cout << composed(3, 4) << std::endl; // 출력: 결과는 7입니다

    return 0;
}

int main() {
    // g: 문자열을 소문자로 변환
    auto to_lower = [](std::string s) {
        std::transform(s.begin(), s.end(), s.begin(), ::tolower);
        return s;
    };

    // f: 문자열 길이 반환
    auto length = [](const std::string& s) {
        return s.length();
    };

    // 합성: 문자열 → 소문자 → 길이
    auto get_lower_length = compose(length, to_lower);

    std::string input = "HelloWorld";
    std::cout << "소문자 길이: " << get_lower_length(input) << std::endl;

    return 0;
}
//소문자 길이: 10



// g: 두 숫자를 더함
auto add = [](int a, int b) { return a + b; };

// f: 결과를 문자열로 변환
auto to_string = [](int x) { return std::to_string(x); };

// compose: f(g(x, y)) 형태로 합성
auto composed = compose(to_string, add);


```




## 🧩 요약
| 항목 | 설명 |
|------|-----| 
| compose | 두 함수를 합성하여 새로운 함수 생성 | 
| std::negate | 값을 음수로 바꾸는 함수 객체 | 
| std::multiplies | 두 값을 곱하는 함수 객체 | 
| 핵심 개념 | 고차 함수, 람다 표현식, 함수 객체 활용 | 

----


# 🧠 C++에서 pipeline 구현하기
C++에서는 템플릿과 람다를 활용해서 비슷한 구조를 만들 수 있어요.

## 🔧 기본 pipeline 함수
template <typename... Funcs>
auto pipeline(Funcs... funcs) {
    return [=](auto input) {
        return ( ... | [=](auto val) { return funcs(val); } )(input);
    };
}


하지만 이건 C++20의 operator| 오버로딩이 필요해서 복잡해질 수 있어요.
그래서 실전에서는 단순한 compose 체인으로 구현하는 게 더 일반적이에요.

## ✅ 실전 예제: compose로 pipeline 구성
```cpp
#include <iostream>
#include <string>
#include <algorithm>

// compose 함수
template <typename F, typename G>
auto compose(F f, G g) {
    return [=](auto... args) {
        return f(g(args...));
    };
}

// pipeline 함수: 여러 함수 연결


template <typename F, typename... Rest>
auto pipeline(F f, Rest... rest) {
    if constexpr (sizeof...(rest) == 0) {
        return f;
    } else {
        return compose(pipeline(rest...), f);
    }
}

int main() {

    auto trim = [](std::string s) {
        auto new_end = std::remove_if(s.begin(), s.end(), [](unsigned char c) {
        return std::isspace(c);
        });
        s.erase(new_end, s.end());
        return s;
    };

    auto to_upper = [](std::string s) {
        std::transform(s.begin(), s.end(), s.begin(), ::toupper);
        return s;
    };

    auto add_prefix = [](std::string s) {
        return "[변환됨] " + s;
    };

    auto process = pipeline(add_prefix, to_upper, trim);

    std::string input = "   Hello World   ";
    std::cout << process(input) << std::endl; // 출력: [변환됨]HELLOWORLD

    return 0;
}
```


## 🔍 핵심 요약
| 구성 요소 | 설명 | 
|----------|-----|
| compose(f, g) | f(g(...)) 형태로 함수 합성 | 
| pipeline(f1, f2, f3) | f3(f2(f1(x))) 형태로 함수 연결 | 
| 람다 함수들 | 각각의 처리 단계 (예: trim → to_upper → add_prefix) | 


---




